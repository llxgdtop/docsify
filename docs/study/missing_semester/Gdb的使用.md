# Gdb的使用

![clip_image001](assets\clip_image001.png)

启动gdb  gdb 文件名

tui enable打开源代码展示窗口

gdb窗口的右上角是程序计数器，如果去汇编代码中（比如所kernel.asm）查找这个地址，就可以看到这个地址对应的就是这个函数的起始地址。如果代码出现了问题，在gdb中看到的地址，你可以直接在kernel.asm找到具体的行，分析问题的原因，然后再向相应的地址设置断点。

Layout asm，可以看到汇编指令；layout reg可以查看寄存器，在寄存器窗口，更新了的寄存器会被高亮出来。layout split可以看源码

如果你关心你设置了哪些断点，或着你跟踪代码的时候迷糊了，你可以在gdb中输入info breakpoints，你可以看到所有设置了的断点。你甚至可以看到这个断点已经被命中了几次。类似的，你也可以通过输入info reg查看寄存器的信息（如果不想打开reg窗口但想看寄存器信息就用info xxx）

 

在gdb中输入info frame，可以看到有关当前Stack Frame许多有用的信息。

如果输入backtrace（简写bt）可以看到从当前调用栈开始的所有Stack Frame。

如果对某一个Stack Frame感兴趣，可以先定位到那个frame（如frame 2）再输入info frame。

 

在GDB中设置断点时,断点会在执行相应语句之前暂停程序运行。

具体来说,当你在GDB中使用break命令在某一行代码处设置断点时,程序在执行到该行代码之前会暂停。这意味着,如果这行代码是一个函数调用、赋值语句或其他语句,断点会在执行该语句之前触发。

例如,对于以下C代码:

```C
int main() {

  int x = 0;

  x = 10;

  printf("x = %d\n", x);

  return 0;

}
```



如果在第3行x = 10;处设置断点,当程序运行到该行时,它会在执行赋值语句之前暂停。此时,x的值仍为初始值0。

 

x/[格式识别码][重复次数][单位大小] [内存地址]

x/2c $a1具体含义为:

x 是检查内存内容的命令

2 表示重复次数，即显示2个单位的内存内容

c 是格式识别码,表示以字符(char)的形式显示内存内容

$a1 是一个内存地址,在RISC-V架构中,$a1是第2个参数寄存器

 

reverse-next的作用是让程序恢复到上一行代码刚执行完时的状态,在它之前要record