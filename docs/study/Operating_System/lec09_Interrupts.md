## 课前内容

设备驱动程序Device driver是⼀段驻留在操作系统内的代码，⽤于管理特定的硬件设备。驱动程序负

责设置好这些硬件设备，告诉设备要执⾏什么动作，处理设备产⽣的中断，并与正在等待该设备的上

层⽤户进程进⾏交互等。

通常情况下，⼤多数的设备驱动程序，都可以看成⼀个分上下部分的结构：顶部top half运⾏在内核空

间中，通常由某⼀个进程的内核线程来运⾏，⽽底部bottom half则在中断产⽣时执⾏，⼤体上就是

Interrupt handler。

当内核希望与设备进⾏⼀些交互时，请求read、write等系统调⽤，驱动程序的top half就会被调⽤，

top half会根据相应请求，让设备开始执⾏⼀些具体的操作（例如从磁盘上读⼀块）；在相关操作完成

后，设备就会产⽣中断，因此驱动程序的bottom half开始执⾏，它会查看设备完成的是什么⼯作，在

适当的时候唤醒等待该⼯作的进程，同时让设备开始做新的⼯作。

⼀个设备驱动程序的top half和bottom half，可以并发地运⾏在不同的CPU上。

 

1

控制台Console是与⽤户进⾏交互的硬件设备，它接受⽤户的输⼊（如键盘输⼊），将其传递给内核

和⽤户程序，进⾏相应的处理，然后再输出结果给⽤户（如输出到屏幕上）。

⾸先，简单地看总体流程：⽤户将会通过键盘键⼊⼀连串字符，通过连接到RISC-V上的UART串⾏端

⼝（UART Serial-port）传输，控制台驱动程序将会顺利地接收这些输⼊。接着，控制台驱动程序处

理其中的⼀些特殊字符（如BackSpace和Ctrl等），并不断累积这些输⼊字符，直到达到完整的⼀⾏

（⼀般⽤户键⼊Enter表示⼀⾏的结束）。最后，⽤户进程，例如shell，就会使⽤read从控制台中读

取这些⼀⾏⾏的输⼊，然后由shell来具体处理它们。

你的键盘输⼊实际上就是由QEMU仿真的UART硬件传输到xv6内核的。

内核可以访问经内存映射的UART控制寄存器。UART经内存映射到从物理地址0x10000000开始的部

分上，它有⼀⼩部分控制寄存器，每个1B⼤⼩。在RHR中保持着UART接收的输⼊，等待内核将其内

容取⾛；THR保持着内核的输⼊，等待UART将其发送。对于内核的read或write指令，将访问对应

的RHR或THR控制寄存器。LSR包含⼀些位，LSR_RX_READY指示RHR中是否有输⼊字符，等待内核将其读出；⼀旦被读出，UART就将其从内部的FIFO缓冲区中移除，直到缓冲区为空时置位

LSR_TX_IDLE。以上是UART的接收部分硬件，发送部分硬件很⼤程度上与其相互独⽴。如果内核往

THR中写⼊了⼀个字节，那么UART就发送该字节。

xv6在main进⾏了控制台的初始化，调⽤consoleinit来完成，然后consoleinit⼜调⽤uartinit初始化

UART（kernel/uart.c），如下所示。uartinit主要的⼯作是写⼊相关的控制寄存器，配置好传输的波特

率，重置FIFO缓冲区，最后开启接收中断receive interrupt和发送完成中断transmit complete

interrupt。之后，每当UART收到⼀个字节的输⼊时，就会产⽣receive interrupt；每当UART完成⼀

个字节的发送时，就会产⽣transmit complete interrupt。xv6的shell可以主动地从控制台读取输

⼊，shell发出read的系统调⽤请求后，最终将导向到控制台驱动程序的top half，并执⾏

consoleread（kernel/console.c）。consoleread主要从缓冲区cons.buf中读取整⾏的输⼊到⽤户空

间中，如果cons.buf中没有字符可读，或者读完了缓冲区中的所有字符但该⾏仍未结束，shell⾃⼰会

睡眠，并等待条件满⾜时才会被唤醒。

接着我们往前⼀步，如果有输⼊字符到达控制台，控制台将会产⽣中断，因此跳转到控制台的中断处

理程序consoleintr，它会将输⼊字符缓冲到cons.buf中，然后返回。直到cons.buf⾥累积了⼀整⾏

的输⼊，consoleintr才会唤醒⼀个⽤户进程的（⽐如shell）consoleread，然后consoleread将缓冲

在cons.buf中的⼀整⾏输⼊，拷⻉到⽤户空间，然后返回到⽤户进程。在consoleintr唤醒⼀个进程的

consoleread时，该进程之前主动地使⽤consoleread读出⼀⾏中的部分输⼊，现在在被唤醒之后，它

能够顺利地读完全部这⼀⾏（到换⾏符'\n'或⽂件结束符'ctrl+D'为⽌）；也可能之前没有进程因调⽤

consoleread⽽睡眠，则consoleintr不会唤醒任何进程，之后⽤户进程主动调⽤consoleread时，同

样也能读出⼀整⾏的⽤户输⼊。

⽤户通过键盘输⼊⼀个字符，到控制台接收到这个字符，在这之间我们通过UART进⾏传输。

当⽤户键下键盘输⼊⼀个字符，且UART的RHR接收到时，UART就会向CPU发出中断（receive

interrupt），在内核中执⾏trap handler。发现是设备中断后，trap handler会跳转到devintr，如下所

示。在devintr中，通过检查scause中的值，发现该设备中断来⾃于外部设备，然后由PLIC（管理着

所有的外部设备中断）告诉CPU，是哪个设备产⽣中断。最后发现是UART之后，devintr就会跳转到

uartintr，即UART的中断处理程序，进⾏相关处理。uartintr（kernel/uart.c）如下所示，它⾸先尝试

从其控制寄存器RHR中读出⼀个字符（我们说过RHR保持着UART接收的输⼊），如果有，直接将该字符交给控制台驱动程序的bottom half，即consoleintr来处理该字符（实际上在UART的中断处理程序中，⼜调⽤了控制台的中断处理程序，但这不是通过中断实现的，并不是中断嵌套），然后

consoleintr做的⼯作正如前⾯我们所说明的那样。但如果RHR中没有字符可读，uartintr并不会阻塞

地等待那些尚未到达RHR的字符，但也不会因此错过它们，因为之后新的字符被⽤户键⼊时，UART

还会发出后续中断。处理完RHR中保持的字符后，UART接着调⽤uartstart，在该函数中，检查

UART的缓冲区⾥是否有需要UART发送的数据，如果有，并且THR为空，就将该字符写⼊到THR

中，UART就会发送该字节，在下⼀⼩节我们将更仔细地说明发送的部分

⽤户键盘输⼊⼀个字符->UART在RHR中接收到该字符，发出中断->xv6接收到中断，陷⼊trap

\>trap handler发现是外部设备中断，设备是UART->调⽤uartintr->发现RHR中有字符可读，调⽤

consoleintr->将输⼊字符缓冲到cons.buf中，如果读到'\n'或'ctrl+D'，说明⽤户输⼊满⾜⼀⾏，就唤

醒consoleread->读出⼀整⾏的⽤户输⼊，拷⻉到⽤户空间中

 

THR (发送保持寄存器): 当数据需要通过UART发送时，数据首先被放置到THR中。UART设备随后从THR中取出数据，并通过串行端口发送出去。在数据发送的过程中，CPU可以继续将数据写入THR（如果THR空闲）。这样做的好处是，CPU不必等待每个字节数据发送完毕才能继续工作，有效提高了系统的效率。

RHR (接收保持寄存器): 与THR相对应，当数据通过串行端口被UART接收时，这些数据首先被存储在RHR中。CPU可以从RHR中读取数据进行处理。这种机制同样使得CPU在等待接收更多数据时可以进行其他任务。

简而言之，关系是这样的：在串行通信过程中，THR和RHR是UART内部用于暂存数据的两个寄存器，分别用于发送和接收数据。它们为数据的异步传输提供了缓冲区，允许CPU和UART设备在处理数据时相对独立，从而提高了通信的效率和系统的整体性能。

 

2

⾸先，我们依然简单地看总体流程：⽤户进程需要产⽣⼀些输出到控制台上，以便通过屏幕显示给⽤

户。所以，⽤户进程，例如shell，通过系统调⽤write，往某个发送缓冲区⾥写⼊⼀些字符；我们通过

UART来传输这些字符，所以我们应该往UART的发送缓冲区⾥写⼊它们，然后⽤户进程就可以返回；

UART会在适当的时候，将⼀个字符写⼊控制寄存器THR；最后，UART将字符成功地发送到了控制

台，控制台呈现输出给⽤户。

⽤户进程请求的write系统调⽤，最终将导向到UART驱动程序的top half，并执⾏uartputc（kernel/

uart.c），如下所示。对于⽤户进程来说，只需要通过uartputc向发送缓冲区中写⼊⼀个字符，并且调

⽤uartstart。

uartstart的主要⼯作是，尝试发送⼀个位于发送缓冲区中的字符（按FIFO的⽅式），如果发送缓冲区

为空，或者控制寄存器THR还持有着字符（这代表着对于上⼀个字符，UART的发送已经就绪，只是

还没发送出去），那么uartstart将会直接返回。如果条件满⾜可以发送，uartstart就会按FIFO的⽅

式，将缓冲区中的⼀个字符写⼊寄存器THR中，之后UART就会发送THR中的字符；同时唤醒⼀个可能在睡眠的uartputc进程，表明现在发送缓冲区空出了位置，该进程可以继续往缓冲区中写⼊字符。

还有⼀个地⽅也会调⽤uartstart，就是前⾯提到的uartintr。前⾯讨论的情况是receive interrupt，这

⾥相关的是transmit complete interrupt，即每当UART发送完⼀个字符之后，就产⽣transmit

complete interrupt。同样地，通过中断引发了trap，内核检查后发现是设备中断，在devintr中发现

是UART中断，最后⼜跳转到了uartintr。如前⾯所示，uartintr的后半部分会调⽤uartstart。你可能

注意到了这其中的延续性：UART发送完⼀个字符，引发了中断，因此调⽤uartstart继续发送新的字

符。⼀般来说，如果⼀个⽤户进程写⼊了多个字符，第⼀个字符由uartputc调⽤uartstart发送，剩下

则的通过transmit complete interrupt发送。

⽆论该字符能不能⻢上被UART发送出去，uartstart都会很快就返回，因此我们可以认为uartstart⼏

乎是⽆阻塞的。再返回到上⼀层，在uartputc中，我们要么会调⽤uartstart，要么让当前进程挂起并

睡眠，因此uartputc也是很快就返回的。所以，UART暴露给⽤户程序或内核的uartputc接⼝是异步

的，⽤户进程的write可以使⽤这种接⼝，因为⽤户进程可以很快地返回或被挂起，从⽽很快地进⾏后

续⼯作或者让出CPU资源。

uartputc也提供了同步，或者说阻塞的版本，uartputc_sync。该版本的接⼝，⽤于满⾜那些需要⻢上

响应的需求，因此CPU就阻塞在某处，直到THR中的字符被发送，然后就把需要发送的新字符写⼊

THR。你也可以看到，该字符不会写⼊发送缓冲区中。事实上，内核的printf就使⽤这个同步的版本，

因为内核打印的消息⽐较重要，我们希望能尽快地显示给⽤户。

I/O并发性是指输⼊/输出（I/O）操作和⽤户进程操作之间的解耦，允许它们并⾏执⾏，从⽽提⾼整体

的系统效率和响应速度。这种模式利⽤两种主要机制来实现：缓冲和中断。

缓冲:

缓冲(Buffering)是⼀种临时存储数据的⽅法。在I/O操作中，缓冲允许数据在被最终处理（⽐如显示在

屏幕上或写⼊硬盘）之前暂时存储在内存中。这意味着设备和进程不需要直接同步。例如，⼀个进程

可以将数据写⼊缓冲区并继续执⾏其他任务，⽽不需要等待数据被物理设备处理。

中断:

中断（Interrupt）是⼀种机制，允许外围设备（如键盘、⿏标或⽹络适配器）通知CPU需要注意的事

件。当这样的事件发⽣时，CPU可以暂时中⽌当前的任务，转⽽处理更紧急的任务（如处理⽤户的键

盘输⼊）。这样，即使当前没有进程明确要求读取这些输⼊数据，设备的操作也能独⽴于⽤户进程进

⾏。

通过这两种机制，即使⽤户程序并不直接与设备交互，⽤户的输⼊和输出操作仍然可以以⾮常⾼效的

⽅式进⾏。这提升了⽤户进程的执⾏效率，因为进程可以在等待慢速I/O操作完成的同时继续进⾏其他

计算任务。简⽽⾔之，I/O并发性通过解耦设备⾏为和⽤户进程⾏为，提供了⼀个系统设计，使得多个

操作可以更加灵活和⾼效地同时进⾏。

UART驱动程序每次从控制寄存器RHR中读出⼀个字节⼤⼩的字符，这种模式称为编程I/O

（Programmed I/O），因为我们通过软件来驱动数据传输。编程I/O的⽅式⽐较简单，但是很难⽤于

⾼速率传输的场合。⼀种更为⼈熟知的⽅式是直接存储器访问DMA（Direct Memory Access），

DMA硬件会直接从RAM中读出数据，或将数据直接写⼊RAM中。现代磁盘和⽹络设备基本都使⽤

DMA，因为它们对传输速率的要求⽐较⾼。DMA中的驱动程序，会在RAM中准备好相应的数据后，

通过写⼊控制寄存器来通知相应设备处理这些数据。UART驱动程序将数据先拷⻉到内核的缓冲区中，

再拷⻉到⽤户空间下。如果数据传输速率低，这么做是可以的，但是两次的复制显然不太⾼效。因

此，⼀些操作系统可以直接在⽤户缓冲区和设备之间拷⻉数据，这通常结合DMA来实现。

![img](assets\clip_image002-1729267591199-1.jpg)

 

3

对于驱动程序的某些数据结构，多个进程会并发地访问它们，因此我们需要锁来保护这些数据结构，

并通过acquire来获取锁。如果不使⽤锁的话，可能会有以下的并发问题：

●两个不同CPU上的进程同时调⽤consoleread。

●即使CPU已经在执⾏consoleread，但硬件要求该CPU响应⼀个控制台（UART）的中断。

 ●当consoleread执⾏时，硬件可能会在不同的CPU上响应⼀个控制台（UART）中断。

 

 4

计时器中断产⽣时，⾸先在机器模式下产⽣⼀个软件中断，提醒内核及时处理计时器到时这⼀事件；

在后续内核进⾏user trap或kernel trap的过程中，如果中断开放，就能够注意到这⼀软件中断，从⽽

执⾏计时器到时的相应逻辑事件（如调度）。我们在第四章中已经介绍过trap的相关部分，最终将由

usertrap或kerneltrap负责响应计时器发出的软件中断，执⾏yield来完成进程切换。有关进程调度的

内容我们将在第七章中说明。

早在xv6的启动阶段，还是机器模式下时，就进⾏了计时器的初始化（kernel/start.c），如下所示。

主要的⼯作有，对CLINT（core-local interruptor）进⾏编程，使其在⼀定时延后产⽣中断；然后设

置⼀个类似trapframe的容器scratch，⽤于在机器模式下保存寄存器和CLINT的地址；最后，设置

mtvec，使得机器模式的trap跳转到timervec，并且开放计时器中断。

计时器中断可以在任何时刻发⽣，不管是在执⾏⽤户或内核代码。（因为在machine mode）

(“中断向量”被称为“向量”，因为它直接指向（指向的“方向”）中断处理代码的地址，就像物理中的向量指向某个方向一样。)

计时器到时，xv6会陷⼊机器模式，陷⼊我们预先在寄存器mtvec中设置好的中断向量timervec中，

timervec主要重置计时器，并且发出软中断software interrupt，然后⽴刻返回。通过发出软中断，

CPU将处理计时器中断的任务交付给了内核，现在内核可以按照与普通中断相同的trap机制来处理该

中断，显然内核也可以屏蔽该软件中断（例如当执⾏类似acquire的原⼦操作时，要关闭中断）。处理

该软件中断的流程在devintr中。

机器模式下的计时器中断vector，我们在上⼀章中介绍过，就是timervec。它保存⼀些在xv6启动阶

段就设置好的机器模式相关寄存器到scratch中，设置CLINT以便产⽣下⼀次计时器中断，并让CPU

发出软件中断，恢复寄存器，然后返回。在计时器中断处理程序中没有C代码。

中断有较⾼的CPU开销，因此⾼速设备如⽹络、磁盘控制器等要设法减少中断的次数。⼀种⽅式是，

对于⼀⼤串的输⼊输出请求，我们执⾏⼀次中断；另⼀种⽅式是，禁⽤中断，⽽让设备驱动程序周期

性地检查设备⼯作是否完成，这种技术称为轮询Polling。如果设备的⼯作很快，轮询是⾼效的，但如

果设备经常处于闲置状态，轮询⼜会浪费CPU资源。⼀些驱动程序采⽤中断和轮询相交替的⽅式，取

决于当前设备的⼯作负载。

 

在plic.c中，。PLIC负责管理处理器（CPU）和外设之间的中断。这段代码主要做了几件事情：初始化PLIC，为特定的硬件线（中断号）设置优先级和使能标志，以及处理中断的认领（claim）和完成（complete）操作。

Hart,硬件线程。



## 课上内容

中断与系统调用主要有3个小的差别：

1asynchronous。当硬件生成中断时，Interrupt handler与当前运行的进程在CPU上没有任何关联。但如果是系统调用的话，系统调用发生在运行进程的context下。

2 concurrency。我们这节课会稍微介绍并发，在下一节课，我们会介绍更多并发相关的内容。对于中断来说，CPU和生成中断的设备是并行的在运行。网卡自己独立的处理来自网络的packet，然后在某个时间点产生中断，但是同时，CPU也在运行。所以我们在CPU和设备之间是真正的并行的，我们必须管理这里的并行。

3program device。我们这节课主要关注外部设备，例如网卡，UART，而这些设备需要被编程。每个设备都有一个编程手册，就像RISC-V有一个包含了指令和寄存器的手册一样。设备的编程手册包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。不过通常来说，设备的手册不如RISC-V的手册清晰，这会使得对于设备的编程会更加复杂。

 

所有的设备都连接到处理器上，处理器上是通过Platform Level Interrupt Control，简称PLIC来处理设备中断。当外围设备触发中断时，中断信号首先被发送到PLIC。PLIC根据配置的优先级等参数判断中断是否应该被送达给处理器核心。如果该中断被允许传递，PLIC则将中断信息发送到一个或多个核心，根据系统配置决定到哪些核心发送。处理器核心接收到中断后，会根据自身的中断处理流程来处理该中断。处理完成后，核心通常需要发送一个信号给PLIC，表明中断已经被处理，这样PLIC就可以将此中断源的状态复位，准备接收下一次中断。倾向于将PLIC或类似的中断控制器功能集成到CPU或SoC中以优化性能和成本。所以一般看不到作为独立组件的PLIC。

 

 

![img](assets\clip_image002-1729267686025-3.jpg)从左上角可以看出，我们有53个不同的来自于设备的中断。这些中断到达PLIC之后，PLIC会路由这些中断。图的右下角是CPU的核，PLIC会将中断路由到某一个CPU的核。如果所有的CPU核都正在处理中断，PLIC会保留中断直到有一个CPU核可以用来处理中断。所以PLIC需要保存一些内部数据来跟踪中断的状态。

具体流程：1PLIC会通知当前有一个待处理的中断

2其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理

3CPU核处理完中断之后，CPU会通知PLIC

4PLIC将不再保存中断的信息

对于XV6来说，所有的CPU都能收到中断，但是只有一个CPU会Claim相应的中断。

 

管理设备的代码称为驱动，所有的驱动都在内核中。我们今天要看的是UART设备的驱动，代码在uart.c文件中。如果我们查看代码的结构，我们可以发现大部分驱动都分为两个部分，bottom/top。

bottom部分通常是Interrupt handler。当一个中断送到了CPU，并且CPU设置接收这个中断，CPU会调用相应的Interrupt handler。Interrupt handler并不运行在任何特定进程的context中，它只是处理中断。

top部分，是用户进程，或者内核的其他部分调用的接口。对于UART来说，这里有read/write接口，这些接口可以被更高层级的代码（比如应用程序）调用。

通常情况下，驱动中会有一些队列（或者说buffer），top部分的代码会从队列中读写数据，而Interrupt handler（bottom部分）同时也会向队列中读写数据。这里的队列可以将并行运行的设备和CPU解耦开来。

![img](assets\clip_image004-1729267686025-4.jpg)通常来说，对设备进行编程是通过memory mapped I/O完成的。

 

实际上“$ ”和“ls”还不太一样，“$ ”是Shell程序的输出，而“ls”是用户通过键盘输入之后再显示出来的。对于“$ ”来说，实际上就是设备会将字符传输给UART的寄存器，UART之后会在发送完字符之后产生一个中断。在QEMU中，模拟的线路的另一端会有另一个UART芯片（模拟的），这个UART芯片连接到了虚拟的Console，它会进一步将“$ ”显示在console上。另一方面，对于“ls”，这是用户输入的字符。键盘连接到了UART的输入线路，当你在键盘上按下一个按键，UART芯片会将按键字符通过串口线发送到另一端的UART芯片。另一端的UART芯片先将数据bit合并成一个Byte，之后再产生一个中断，并告诉处理器说这里有一个来自于键盘的字符。之后Interrupt handler会处理来自于UART的字符。我们接下来会深入通过这两部分来弄清楚这里是如何工作的。

RISC-V有许多与中断相关的寄存器：

1SIE（Supervisor Interrupt Enable）寄存器。这个寄存器中有一个bit（E）专门针对例如UART的外部设备的中断；有一个bit（S）专门针对软件中断，软件中断可能由一个CPU核触发给另一个CPU核；还有一个bit（T）专门针对定时器中断。我们这节课只关注外部设备的中断。

2SSTATUS（Supervisor Status）寄存器。这个寄存器中有一个bit来打开或者关闭中断。每一个CPU核都有独立的SIE和SSTATUS寄存器，除了通过SIE寄存器来单独控制特定的中断，还可以通过SSTATUS寄存器中的一个bit来控制所有的中断。

3SIP（Supervisor Interrupt Pending）寄存器。当发生中断时，处理器可以通过查看这个寄存器知道当前是什么类型的中断。

4SCAUSE寄存器，这个寄存器我们之前看过很多次。它会表明当前状态的原因是中断。

5STVEC寄存器，它会保存当trap，page fault或者中断发生时，CPU运行的用户程序的程序计数器，这样才能在稍后恢复程序的运行。

 

具体top and bottom编程见           https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec09-interrupts/9.4-xv6-set-interrupt ;

 

与中断相关的并发，并发加大了中断编程的难度。这里的并发包括以下几个方面：

1设备与CPU是并行运行的。例如当UART向Console发送字符的时候，CPU会返回执行Shell，而Shell可能会再执行一次系统调用，向buffer中写入另一个字符，这些都是在并行的执行。这里的并行称为producer-consumer并行。

2中断会停止当前运行的程序。例如，Shell正在运行第212个指令，突然来了个中断，Shell的执行会立即停止。对于用户空间代码，这并不是一个大的问题，因为当我们从中断中返回时，我们会恢复用户空间代码，并继续执行执行停止的指令。我们已经在trap和page fault中看过了这部分内容。但是当内核被中断打断时，事情就不一样了。所以，代码运行在kernel mode也会被中断，这意味着即使是内核代码，也不是直接串行运行的。在两个内核指令之间，取决于中断是否打开，可能会被中断打断执行。对于一些代码来说，如果不能在执行期间被中断，这时内核需要临时关闭中断，来确保这段代码的原子性。

3驱动的top和bottom部分是并行运行的。例如，Shell会在传输完提示符“$”之后再调用write系统调用传输空格字符，代码会走到UART驱动的top部分（注，uartputc函数），将空格写入到buffer中。但是同时在另一个CPU核，可能会收到来自于UART的中断，进而执行UART驱动的bottom部分，查看相同的buffer。所以一个驱动的top和bottom部分可以并行的在不同的CPU上运行。这里我们通过lock来管理并行。因为这里有共享的数据，我们想要buffer在一个时间只被一个CPU核所操作。

producer(比如shell调用的uartputc）可以一直写入数据，直到写指针 + 1等于读指针，因为这时，buffer已经满了。当buffer满了的时候，producer必须停止运行。我们之前在uartputc函数中看过，如果buffer满了，代码会sleep，暂时搁置Shell并运行其他的进程。

Interrupt handler，也就是uartintr函数，在这个场景下是consumer，每当有一个中断，并且读指针落后于写指针，uartintr函数就会从读指针中读取一个字符再通过UART设备发送，并且将读指针加1。当读指针追上写指针，也就是两个指针相等的时候，buffer为空，这时就不用做任何操作。这里的buffer存在于内存中，并且只有一份，所以，所有的CPU核都并行的与这一份数据交互。所以我们才需要lock。

以上为输出$到console的部分。它调用的是consolewrite。

 

输出ls到console部分：

这里与UART类似，也有一个buffer，包含了128个字符。其他的基本一样，也有producer和consumser。但是在这个场景下Shell变成了consumser，因为Shell是从buffer中读取数据。而键盘是producer，它将数据写入到buffer中。从consoleread函数中可以看出，当读指针和写指针一样时，说明buffer为空，进程会sleep。所以Shell在打印完“$ ”之后，如果键盘没有输入，Shell进程会sleep，直到键盘有一个字符输入。所以在某个时间点，假设用户通过键盘输入了“l”，这会导致“l”被发送到主板上的UART芯片，产生中断之后再被PLIC路由到某个CPU核，之后会触发devintr函数，devintr可以发现这是一个UART中断，然后通过uartgetc函数获取到相应的字符，之后再将字符传递给consoleintr函数。默认情况下，字符会通过consputc，输出到console上给用户查看。之后，字符被存放在buffer中。在遇到换行符的时候，唤醒之前sleep的进程，也就是Shell，再从buffer中将数据读出。

 

 

 

如果你有一个高性能的设备，例如你有一个千兆网卡，这个网卡收到了大量的小包，网卡每秒可以生成1.5Mpps，这意味着每一个微秒，CPU都需要处理一个中断，这就超过了CPU的处理能力。那么当网卡收到大量包，并且处理器不能处理这么多中断的时候该怎么办呢？

这里的解决方法就是使用polling。除了依赖Interrupt，CPU可以一直读取外设的控制寄存器，来检查是否有数据。对于UART来说，我们可以一直读取RHR寄存器，来检查是否有数据。现在，CPU不停的在轮询设备，直到设备有了数据。

这种方法浪费了CPU cycles，当我们在使用CPU不停的检查寄存器的内容时，我们并没有用CPU来运行任何程序。在我们之前的例子中，如果没有数据，内核会让Shell进程sleep，这样可以运行另一个进程。

所以，对于一个慢设备，你肯定不想一直轮询它来得到数据。我们想要在没有数据的时候切换出来运行一些其他程序。但是如果是一个快设备，那么Interrupt的overhead也会很高，那么我们在polling设备的时候，是经常能拿到数据的，这样可以节省进出中断的代价。

所以对于一个高性能的网卡，如果有大量的包要传入，那么应该用polling。对于一些精心设计的驱动，它们会在polling和Interrupt之间动态切换（注，也就是网卡的NAPI）。

 

下面简要介绍中断处理的一般流程：

1. 中断触发

硬件中断：由外部设备引起的中断。当外部设备完成其任务或需要CPU注意时，它会通过发送信号到中断线来通知CPU。

软件中断：由程序指令（如x86体系的INT指令）直接生成。软件中断可以用于系统调用、异常处理等。

2. 中断识别

当CPU接收到中断信号后，会在当前指令执行完成后（保证指令执行的原子性）响应中断。

为了处理中断，当前正在执行的进程需要被暂停。CPU保存当前进程的状态，如程序计数器（PC）、标志寄存器等信息，以便稍后能够恢复执行。

3. 执行中断服务程序

CPU查询中断向量表（一个存储了中断服务程序入口地址列表的数据结构），根据中断类型找到相应的中断服务例程（ISR，Interrupt Service Routine）的地址。

CPU将控制权转移到相应的中断服务例程。该服务程序包含处理中断所需的代码。

4. 中断处理

中断服务例程执行必要的操作处理中断请求。操作可能包括读取或写入数据到外设、调整系统状态、处理异常情况等。

部分系统中，ISR的执行需要尽可能快，以避免阻塞其他中断的处理。因此，某些处理可能会延后或者交给其他机制（如任务队列）异步处理。

5. 中断返回

一旦中断服务例程完成其工作，它会执行一个特殊的返回指令（如x86体系的IRET），恢复之前被中断的进程状态，并将控制权返回给该进程继续执行。

在多中断级别的系统中，此时可能会允许其他等级更高的中断被处理。

 

"Hart" 在计算机架构领域，特别是与 RISC-V 指令集架构相关时，是指“硬件线程”（Hardware Thread）的缩写。在多核处理器或多线程处理器的设计中，一个核（core）可以有多个执行单元（harts），使得该核能够并行处理多个线程或任务。这类似于其他架构中的逻辑核心或硬件线程概念。

别忘了xv6上面有两个uart

 

 

### 在xv6中设置中断

启动系统时，首先是start()，将所有的中断都设置，这里将所有的中断都设置在Supervisor mode，然后设置SIE寄存器来接收External，软件和定时器中断，之后初始化定时器。

Start会跳到main函数，main函数里面首先是

① consoleinint()；（因为第一个外设是console）

Consoleinit中调用了uartinit()，这里的流程是先关闭中断，之后设置波特率，设置字符长度为8bit，重置FIFO，最后再重新打开中断。运行完后，理论上uart就可以生成中断了；

② plic()（要设置这个controller中断才能被CPU感知）

它调用了plicinit()，设置plic接收来自UART的中断，进而将中断路由到CPU。类似的，代码的第二行设置PLIC接收来自IO磁盘的中断。

③ plicinithart()

在plicinithart函数中，每个CPU的核都表明自己对来自于UART和VIRTIO的中断感兴趣。因为我们忽略中断的优先级，所以我们将优先级设置为0。

④ scheduler()

函数主要是运行进程。但是在实际运行进程之前，会执行intr_on函数来使得CPU能接收中断。intr_on函数只完成一件事情，就是设置SSTATUS寄存器，打开中断标志位。

 

### 输入$到console（uart驱动的top部分）

系统启动后运行第一个用户进程位于init.c中的main，main中

1启动系统调用mknod()，其作用是创建一个特殊文件，这里特指设备文件，使用户空间程序能够以文件的方式访问硬件设备。它的参数为“console”，CONSOLE,0；0代表文件描述符0。

2通过dup创建stdout和stderr。最终文件描述符0，1，2都用来代表Console。

3通过exec来执行shell程序（sh.c）

Shell程序首先打开文件描述符0，1，2。之后Shell向文件描述符2打印提示符“$ ”（int getcmd函数），Shell程序只是向文件描述符2写了数据，它并不知道文件描述符2对应的是什么，其实对应的就是console。（简而言之就是shell通过getcmd函数向console打印$)

4在getcmd中，fprintf()->vprintf()->putc()->write系统调用->sys_write()->filewrite()（位于filc.c）在filewrite函数中首先会判断文件描述符的类型。mknod生成的文件描述符属于设备（FD_DEVICE），而对于设备类型的文件描述符，我们会为这个特定的设备执行设备相应的write函数。因为我们现在的设备是Console，所以我们知道这里会调用console.c中的consolewrite函数。

5在consolewrite()中，先通过either_copyin将字符拷入，之后调用uartputc函数（这个相当于producer）。uartputc函数将字符写入给UART设备，它会实际的打印字符。在函数中第一件事情是判断环形buffer是否已经满了。如果读写指针相同，那么buffer是空的，如果写指针加1等于读指针，那么buffer满了。当buffer是满的时候，向其写入数据是没有意义的，所以这里会sleep一段时间，将CPU出让给其他进程。当然，对于我们来说，buffer必然不是满的，因为提示符“$”是我们送出的第一个字符。所以代码会走到else，字符会被送到buffer中，更新写指针，之后再调用uartstart函数。

6在uartstart()中，uartstart就是通知设备UART硬件执行操作。首先是检查当前设备是否空闲，如果空闲的话，我们会从buffer中读出数据，然后将数据写入到THR（Transmission Holding Register）发送寄存器。（这里相当于告诉设备，我这里有一个字节需要你来发送。）UART设备会将数据送出，一旦数据送到了设备，4中的write系统调用会返回(从uartstart一步步返回），用户应用程序Shell就可以继续执行。注意期间并没有像trap那样子停下来保存寄存器什么的（那个在下面），只有函数调用、返回之类的。就剩下它要处理这个数据这个中断了。

 

在某个时间点，我们会收到中断，因为我们之前设置了要处理UART设备中断。

 

### 输出$到console即屏幕上（trap handler部分，书接上回，uart驱动的bottom部分）

之前已经在SSTATUS寄存器中打开了中断，所以处理器（PLIC）会被中断。假设生成了一个中断并且发向了PLIC，PLIC会将中断路由给一个特定的CPU核，并且如果这个CPU核设置了SIE寄存器的E bit（注，针对外部中断的bit位），那么会发生以下事情：

1首先，会清除SIE寄存器相应的bit，这样可以阻止CPU核被其他中断打扰，该CPU核可以专心处理当前中断。处理完成之后，可以再次恢复SIE寄存器相应的bit。

2之后，会设置SEPC寄存器为当前的程序计数器。我们假设Shell正在用户空间运行，突然来了一个中断，那么当前Shell的程序计数器会被保存。

3之后，要保存当前的mode。在我们的例子里面，因为当前运行的是Shell程序，所以会记录user mode。

4再将mode设置为Supervisor mode。

5最后将程序计数器的值设置成STVEC的值。（注，STVEC用来保存trap处理程序的地址）在XV6中，STVEC保存的要么是uservec或者kernelvec函数的地址，具体取决于发生中断时程序运行是在用户空间还是内核空间。在我们的例子中，Shell运行在用户空间，所以STVEC保存的是uservec函数的地址。而从之前的课程我们可以知道uservec函数会调用usertrap函数。所以最终，我们在usertrap函数中。

7在usertrap中的devintr函数中，首先会通过SCAUSE寄存器判断当前中断是否是来自于外设的中断。如果是的话，再调用plic_claim函数来获取中断。

8 plic_claim函数位于plic.c文件中。在这个函数中，当前CPU核会告知PLIC，自己要处理中断，PLIC_SCLAIM会将中断号返回，对于UART来说，返回的中断号是10。即irq=10为UART的中断，那么会调用uartintr函数（相当于consumer）。

9在uartintr中，因为我们现在还没有通过键盘输入任何数据，所以UART的接受寄存器（RHR）现在为空。所以代码会直接运行到uartstart函数，这个函数会将Shell存储在buffer中的任意字符送出。实际上在提示符“$”之后，Shell还会输出一个空格字符，write系统调用可以在UART发送提示符“$”的同时，并发的将空格字符写入到buffer中。所以UART的发送中断触发时，可以发现在buffer中还有一个空格字符，之后会将这个空格字符送出。

 

写入“l”

有时Shell会调用read从键盘中读取字符。 在read系统调用的底层，会调用fileread函数。（和write一样）在这个函数中，如果读取的文件类型是设备，会调用相应设备的read函数。在这个例子中就是consoleread()，在这个场景下Shell变成了consumser，因为Shell是从buffer中读取数据。而键盘是producer，它将数据写入到buffer中。从consoleread函数中可以看出，当读指针和写指针一样时，说明buffer为空，进程会sleep。所以Shell在打印完“$ ”之后，如果键盘没有输入，Shell进程会sleep，直到键盘有一个字符输入。所以在某个时间点，假设用户通过键盘输入了“l”，这会导致“l”被发送到主板上的UART芯片，产生中断之后再被PLIC路由到某个CPU核，之后会触发devintr函数，devintr可以发现这是一个UART中断，然后通过uartgetc函数获取到相应的字符，之后再将字符传递给consoleintr函数。默认情况下，字符会通过consputc，输出到console上给用户查看。之后，字符被存放在buffer中。在遇到换行符的时候，唤醒之前sleep的进程，也就是Shell，再从buffer中将数据读出。

 

 