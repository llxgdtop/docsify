## 操作系统的三大重要部分：虚拟化、并发、持久性

应用程序的函数调用和系统调用相似，系统调用是操作系统提供的服务的接口，所以系统调用长什么样，应用程序期望从系统调用得到什么返回。

 

通常来说，当你输入内容时，你是在告诉Shell运行相应的程序。所以当我输入ls时，实际的意义是我要求Shell运行名为ls的程序，文件系统中会有一个文件名为ls，这个文件中包含了一些计算机指令，所以实际上，当我输入ls时，我是在要求Shell运行位于文件ls内的这些计算机指令

 

如果pid等于0，那么这必然是子进程

exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令.从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令,如exec（"echo",argv),操作系统从名为echo的《《文件中加载指令到当前的进程》》中，并替换了当前进程的内存，之后开始执行这些新加载的指令(即argv)。简单来说：一个程序如何用文件中的另一个程序来替代自己

 

两个参数是给读入命令行参数的

argc表示参数个数，包括执行文件名

argv存放参数，包括执行文件名

 

//pipe(pipefd) 系统调用会创建管道

//pipefd[0]指管道的读取端，1指管道的写入端

 

close系统调用释放文件描述符，使其可供将来重用open,pipe，或dup系统调用。新分配的文件描述符始终是当前进程中编号最小的未使用描述符。使用管道的时候，可以先用close来关闭某些端，避免有多余的输入输出

 

子进程调用 close 和 dup 使文件描述符 0 引用管道的读端，并关闭 p 中的文件描述符，并调用 exec 运行 wc。当 wc 从其标准输入端读取时，它将从管道中读取。

close(0); // 释放文件描述符 0

dup(p[0]); // 复制一个 p[0](管道读端)，此时文件描述符 0（标准输入）也引用管道读端，故改变了标准输入。即原本是写标准输入0的，现在可以用p【0】

 

 

区分好管道描述符和文件描述符，文件描述符0为标准输入，1指标准输出（显示器），pipefd【0】读取，fd【1】写入

 

read从文件描述符fd所代表的文件中读n个字节进缓冲区buf中

write从缓冲区buf中写入n个字节到fd所代表的文件中

 

管道命令（|）的作用：将左侧命令的标准输出转换为标准输入但像echo "hello world" | echo就不行，因为echo命令不接受管道标准输入作为参数

故此时就有xargs命令，echo "hello world" | xargs echo即可，因为它把左边的标准输入转为命令行参数hello world，传给第二个echo命令，真正执行的命令紧跟在xargs后面，接受它传过来的参数

 

exec ls   #在 shell 中执行 ls，ls 结束后不返回原来的 shell 中了

exec    #file 中的内容作为标准输入（替代 STDIN）

exec >file #将标准输出写入file（替代STDOUT）

exec 3   #将 file 读入到文件描述符 3 中（此时，创建了文件描述符 3）

sort <&3  #将文件描述符3作为临时输入，用于 sort 排序

exec 4>file #将写入文件描述符 4 中的内容写入 file 中（此时，创建了文件描述符 4）

ls >&4  #ls将不会有显示，直接写入文件描述符 4 中了，即上面的 file 中

exec 5<&4 #创建文件描述符 4 的拷贝文件描述符 5

exec 3<&- #关闭文件描述符 3

[root@centos7 ~]# echo "mingongge"

mingongge

[root@centos7 ~]# exec -c echo mingongge

mingongge

可见收藏夹

 

 

子进程先是close(0)关闭了fd0。再通过dup(p[0])，将新分配的fd（现在是fd0）指向与p[0]（也就是管道的读端）对应的同一文件。因此，现在标准输入fd0已经被绑定到了管道的读端，这就完成了I/O的重定向。

以下两行命令执行相同的任务，区别在于是否使用管道。

echo hello world | wc

echo hello world >/tmp/xyz; wc </tmp/xyz

在这个例子里，使用管道的第一种方式具有多个优势。

管道自动清理相关资源（分配的内核缓冲区），而临时文件则会保留，需要另外清理。

管道可以传输任意长的字节流，文件重定向则需要磁盘上有足够空间。

管道左右两边的程序是可以并行执行的，而文件方式则必须等待第一个命令的完成。

如果你正在实现进程间通信，管道的阻塞读写会比文件的非阻塞语义更有效。

/"代表根目录，"."代表当前目录，".."代表上一级目录等。如果路径不是以"/"起始的，则默认为从调用进程的当前目录位置开始，这个目录位置可以通过chdir(char* dir)来改变，一个简单的例子如下，两种打开文件c的方式，效果都是一样的。

chdir("/a");

chdir("b");

open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);

区别是，一个文件本身可以有很多个名字，即links，但它们都对应同一个底层的文件，即inode。更具体地，每一个link都有一个在相应目录中的条目对应，该目录条目包含了文件名和指向inode的指针。inode则是一个文件的元数据metadata，包含了文件的类型（普通文件、目录或设备）、文件长度、文件在磁盘上的位置、文件的links数量等。link(char* file1, char* file2)对于一个已存在的文件，为它创建一个新的link，因此这个文件也拥有了新的别名，下面是一个简单例子。

open("a", O_CREATE|O_WRONLY);

link("a", "b");对应有unlink（文件名），只有当它的nlink计数减为0，而且已经没有文件描述符指向它，才会释放保存在磁盘上的，该文件相应的inode block和data block。