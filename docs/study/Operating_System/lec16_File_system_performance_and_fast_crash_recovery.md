## 课前内容

⽂件系统对应⽤程序的表现⽅式是：⼀个操作系统通常需要遵守某些约定的⽂件名，并且⽂件具有某些以特定⽅式解释的属性。

 

我们主要关⼼的是恢复崩溃⽂件系统内容的可靠性，我们可以确定其中的⼏个⽅⾯：

●   **保持（**Preservation**）**：崩溃前磁盘上稳定的数据永远不会被损坏。显然，崩溃时正在写⼊的

⽂件不能保证完全完好⽆损，但是恢复系统不能碰磁盘上已经安全的任何⽂件。

●   **可预测性（**Predictability**）**：我们必须恢复的故障模式应该是可预测的，以便我们可靠地恢复。

●   **原⼦性（Atomicity）**：许多⽂件系统操作需要⼤量独⽴的IO 来完成。⼀个很好的例⼦是将⽂件从⼀个⽬录重命名到另⼀个⽬录。如果这样的⽂件系统操作在磁盘上完全完成，或者在恢复完成后完全撤销，恢复就是原⼦性的。（对于重命名的例⼦，恢复应该在崩溃后保留提交给磁盘的旧⽂件名或新⽂件名，但不能两者都保留。）

 

### 事务剖析

当考虑⽇志⽂件系统时，⼀个核⼼概念是事务，对应于⽂件系统的单个更新。应⽤程序发出的任何单个⽂件系统请求都会产⽣⼀个事务，并且包含该请求产⽣的所有更改的元数据。

 

在事务中还有⼀个我们必须注意的隐藏操作。事务还包括读取⽂件系统的现有内容，这在事务之间强加了顺序。修改磁盘上块的事务不能在读取新数据并根据读取的内容更新磁盘的事务之后提交。即使两个事务从来没有尝试写回相同的块，依赖性也是存在的⸺想象⼀个事务从⽬录中的⼀个块中删除⽂件名，另⼀个事务将相同的⽂件名插⼊到不同的块中。这两个操作在它们写⼊的块中可能不会重叠，但是第⼆个操作只有在第⼀个操作成功后才有效（违反这⼀操作将导致重复的⽬录条⽬）。

 

最后，除了元数据更新之间的排序之外，还有⼀个排序要求。在我们提交将新块分配给⽂件的事务之前，我们必须绝对确保事务创建的所有数据块实际上都已写⼊磁盘（我们称这些数据块为依赖数据 dependent data）。忽略此要求实际上不会损害⽂件系统元数据的完整性，但它可能会导致新⽂件崩溃恢复后仍包含以前的⽂件内容，这是⼀个安全⻛险，也是⼀个⼀致性问题。

 

### 事务合并

传统数据库事务和⽂件系统之间有许多不同之处。

 

两个最⼤的区别是⽂件系统没有事务中⽌，所有⽂件系统事务都相对短暂。⽽在数据库中，我们有时想中途中⽌事务，丢弃我们迄今为⽌所做的任何更改。当我们开始对⽂件系统进⾏任何更改时，我们已经检查了更改是否可以合法完成。

 

第⼆个区别⸺⽂件系统事务存在期很短⸺这很重要，因为这意味着我们可以极⼤地简化事务之间的依赖关系。如果我们必须满⾜⼀些⾮常⻓期的事务，那么我们需要允许事务以任何顺序独⽴提交，只要它们彼此不冲突，否则⼀个停滞不前的事务可能会拖累整个系统。然⽽，如果所有事务都⾜够快，

那么我们可以要求事务以严格的顺序提交到磁盘，⽽不会明显损害性能。

 

所以与为每个⽂件系统更新创建单独的事务不同，我们只是经常创建⼀个新事务，并允许所有⽂件系统服务调⽤将它们的更新添加到单个系统范围的复合事务中。

 

这种机制有⼀个很⼤的优点。因为复合事务中的所有操作都将⼀起提交到⽇志中，所以我们不必为任何经常更新的元数据块编写单独的副本。在复合事务的⽣命周期中，任何多次更新的块只需要提交到磁盘⼀次。关于何时提交当前复合事务并启动新事务的决定是⼀个应该由⽤户控制的策略决定，因为它涉及到影响系统性能的权衡。

 

### ⽂件系统⽇志的格式

⽇志⽂件的⼯作很简单：它在我们提交事务的过程中记录⽂件系统元数据块的新内容。⽇志的唯⼀其他要求是我们必须能够原⼦地提交它包含的事务。

我们向⽇志写⼊三种不同类型的数据块：元数据块、描述符块和头块（metadata, descriptor and header blocks）。

⽇志元数据块包含由事务更新的单个⽂件系统元数据块的全部内容。这意味着，⽆论我们对⽂件系统元数据块做了多么⼩的更改，我们都必须写出整个⽇志块来记录更改。然⽽，由于两个原因，这⼀成本相对较低：

●   ⽆论如何，⽇志写⼊⾮常快，因为对⽇志的⼤多数写⼊都是顺序的，我们可以很容易地将⽇志

IO  批处理成⼤型集群，磁盘控制器可以有效地处理这些集群；

●   通过将更改后的元数据缓冲区的全部内容从⽂件系统缓存写⼊⽇志，我们可以避免在⽇志代码中执⾏⼤量CPU ⼯作。

Linux内核已经为我们提供了⼀种⾮常有效的机制，可以将buffer cache 中现有块的内容写到磁盘上的不同位置。buffer cache 中的每个缓冲区都由⼀个名为buffer_head 的结构体描述，该结构体包括缓冲区的数据要写到哪个磁盘块的信息。如果我们想将整个缓冲区块在不⼲扰buffer_head 的情况下写

⼊新位置，我们可以简单地创建⼀个新的临时buffer_head，将旧的描述复制到其中，然后编辑临时 buffer_head 中的设备块编号字段，以指向⽇志⽂件中的块。然后，我们可以将临时buffer_head 直接提交给设备IO 系统，并在IO 完成后丢弃它。

描述符块是描述其他⽇志元数据块的⽇志块，每当我们要将元数据块写出到⽇志时，我们需要记录下元数据通常安置在哪些磁盘块，这样恢复机制就可以将元数据复制回主⽂件系统中。在⽇志中的每⼀组元数据块之前都会写出⼀个描述符块，其中包含要写⼊的元数据块的数量加上它们的磁盘块号。 描述符块和元数据块都按顺序写⼊⽇志，每当我们运⾏超过末尾时，都会从⽇志的开头重新开始。在任何时候，我们都维护当前的⽇志头（最后写⼊的块的块号）和尾部（⽇志中尚未取消固定的最⽼的块，如下所述）。每当我们⽤完⽇志空间时⸺⽇志的头部已经循环回来并赶上了尾部⸺我们会停⽌新的⽇志写⼊，直到⽇志的尾部被清理⼲净，以释放更多的空间。

最后，⽇志⽂件包含⼀些位于固定位置的头块。这些头块记录了⽇志的当前头部和尾部，加上序列 号。在恢复时，头块被扫描以找到序列号最⾼的块，当我们在恢复过程中扫描⽇志时，我们只是运⾏从尾部到头部的所有⽇志块，就像头块中记录的那样。

 

### ⽇志的提交和检查点

在某个时候，要么是因为上次提交后我们已经等了⾜够⻓的时间，要么是因为⽇志中的空间不⾜，我们希望将未完成的⽂件系统更新作为⼀个新的复合事务提交到⽇志中。

复合事务被完全提交后，我们仍然没有完成它。我们需要跟踪记录在事务中的元数据缓冲区，这样我们就可以注意到它们何时被写回磁盘上的主位置。

回想⼀下，当我们提交事务时，新更新的⽂件系统块位于⽇志中，但尚未同步回磁盘上的永久家块

（家块就是写⼊操作对应的磁盘中⽂件系统对应的块，我们需要保持旧块的这种不同步，以防在提交

⽇志之前崩溃）。⼀旦提交了⽇志，磁盘上的旧版本就不再重要，我们可以在闲暇时将缓冲区写回它们的主位置。但是，在同步完这些缓冲区之前，我们不能删除⽇志中数据的副本。

要完全提交并完成事务的检查点，我们将经历以下阶段：

1     关闭事务。在此刻，我们会建⽴⼀个新的事务以记录未来开始的任何⽂件系统操作。任何现有

的、不完整的操作仍然会使⽤现有的事务：我们不能在多个事务上拆分单个⽂件系统操作！

2     开始将事务刷新到磁盘。在⼀个单独的log-writer 内核线程的上下⽂中，我们开始向⽇志写⼊所有被事务修改过的元数据缓冲区。在这个阶段，我们还必须写⼊任何依赖数据（参⻅上⾯的部分：事务解剖）。

3     提交缓冲区后，将其标记以固定事务，直到它不再脏（它已通过通常的写回机制写回主存储）。

4     等待此事务中所有未完成的⽂件系统操作完成。我们可以在所有操作完成之前安全地开始写⽇志，允许这两个步骤在某种程度上重叠会更快。

5     等待所有未完成的事务更新完全记录在⽇志中。

4. 更新⽇志头块以记录⽇志的新头部和尾部，将事务提交到磁盘。space released in the journal

can now be reused by a later transaction.

7. 当我们将事务的更新缓冲区写到⽇志中时，我们将它们标记以将事务固定在⽇志中。只有当这些缓冲区已同步到磁盘上的主缓冲区时，它们才会解除固定。只有当事务的最后⼀个缓冲区取消固定时，我们才能重⽤事务占⽤的⽇志块。当发⽣这种情况时，写⼊另⼀组⽇志头，记录⽇志尾部的新位置。⽇志中释放的空间现在可以由以后的事务重⽤。

 

### 事务间冲突

为了提⾼性能，我们在提交事务时不会完全暂停⽂件系统更新。相反，我们创建⼀个新的复合事务，在其中记录提交旧事务时到达的更新。

这就留下了⼀个问题，如果⼀个更新想要访问被另⼀个更新所占有的元数据缓冲区，⽽另⼀个更新包含于当前正在提交的旧事务，此时该怎么办。

 

如果新事务只想读取有问题的缓冲区，那么没有问题：我们已经在两个事务之间创建了读/ 写依赖关系，但是由于复合事务总是以严格的顺序提交，我们可以安全地忽略冲突。

如果新事务想要写⼊缓冲区，事情就⽐较复杂了，我们需要缓冲区的旧副本来提交第⼀个事务，但是我们不能让新事务在不让它修改缓冲区的情况下继续进⾏。

这⾥的解决⽅案是在这种情况下创建缓冲区的新副本。将⼀份副本提供给新事务以进⾏修改。另⼀个由旧事务保留，并将像往常⼀样提交到⽇志。⼀旦事务提交，此副本将被删除。

 

 

事务性元数据日志（Transactional Metadata Journal）是一种用于文件系统的技术，旨在提高文件系统在崩溃后的恢复速度和可靠性。它通过记录文件系统元数据的变化来确保在系统崩溃时可以快速、一致地恢复文件系统状态。下面是对事务性元数据日志的详细解释：

**基本概念**

**1**    **事务**：
 事务是一个原子操作单元，包含了一系列必须完整完成或完全撤销的文件系统操作。文件系统事务通常包括对元数据（如文件的创建、删除、修改等）的更新。

**2**    **元数据**：
 元数据是描述文件系统结构和文件属性的数据，包括 inode 表、目录项、位图等。它们不是文件的实际内容，而是文件系统管理文件的必要信息。

**事务性元数据日志的工作原理**

**1**    **日志记录**：
 在执行文件系统操作（如创建文件、删除文件）之前，系统首先将这些操作的相关元数据更改记录到日志中。这个日志通常保存在一个特殊的区域中，以确保其快速访问和更新。

**2**    **提交事务**：
 当所有相关的元数据更改都成功记录到日志后，系统会将这些更改实际应用到文件系统中。这时，事务被认为是提交（commit）了。

**3**    **日志回放**：
 如果系统发生崩溃，在重启时，文件系统会通过检查日志来确定哪些事务已经提交但还未完成。这些未完成的事务将被重新应用，以确保文件系统的一致性和完整性。

**优点**

**1**    **加快恢复速度**：
 因为只需要检查和重放日志中的事务，而不是扫描整个文件系统，恢复时间大大缩短。

**2**    **提高可靠性**：
 通过确保事务的原子性和一致性，减少了崩溃后数据不一致的风险。

**3**    **简化恢复过程**：
 自动日志回放简化了崩溃后的恢复操作，无需人工干预。

**实际应用**

事务性元数据日志在许多现代文件系统中得到了广泛应用，如：

·     **ext3** **和** **ext4**：Linux 文件系统，继承自 ext2，但增加了日志功能。

·     **NTFS**：Windows 文件系统，包含事务性日志功能。

·     **XFS**：高性能文件系统，特别适用于大文件和并发访问场景。

 

 

**详细步骤**

**1**    **写入数据块**：

o  **数据日志记录方式**：数据块的内容首先被写入日志，然后在日志中记录数据块位置的元数据更新。

o  **仅元数据日志记录方式**：数据块可以立即写入磁盘，不需要等待元数据更新。这种方式依赖于确保元数据更新之前，所有相关的数据块已经正确写入。

**2**    **记录元数据更改到日志**：

o  所有涉及的元数据更改（如文件大小、数据块指针等）被记录到日志中。

**3**    **提交事务**：

o  确保所有元数据更改都已成功写入日志后，系统会进行事务提交。此时，事务被认为是“已提交”。

**4**    **应用元数据更改到文件系统**：

o  在事务提交后，日志中的元数据更改会被应用到文件系统的实际位置。

**5**    **日志回收和清理**：

o  确认元数据和数据块都已正确更新后，日志中对应的条目可以被标记为已处理并最终清理。

 

如果写入数据块后，在记录元数据更改到日志之前断电了怎么办？这个时候是不可恢复的，它会被判断为未完成事务，尽管数据块已经写入，由于没有对应的元数据更新，这些数据块被视为孤立数据，不会被文件系统引用。（后续会通过垃圾回收机制等等方式从而让这些垃圾块重新能使用）

 

为什么这种文件系统比元数据和数据都一起写入磁盘的文件系统更快：

**优化的写入流程**

**1**    **异步写入**：

o  事务性元数据日志系统允许数据块和元数据的写入操作在时间上分离。数据块可以直接写入磁盘，而元数据的更改被记录到日志中。这种异步写入减少了每次写操作的等待时间，从而提高了写入性能。

**2**    **日志的顺序写入**：

o  日志记录通常是顺序写入，而不是随机写入。顺序写入比随机写入更快，因为它减少了磁盘寻道时间和旋转延迟。

**3**    **批量处理**：

o  日志系统可以批量处理多个元数据更改，减少了每次写操作的开销。批量处理提高了写入吞吐量和效率。

**减少写放大效应**

**1**    **数据块的直接写入**：

o  在仅元数据日志记录的系统中，数据块可以直接写入其最终位置，而不是先写入日志再从日志中写回磁盘。这样减少了写放大效应（write amplification），即减少了同一数据块需要多次写入的情况。

**2**    **减少元数据写入频率**：

o  通过记录元数据更改到日志而不是每次更改都直接写入元数据区域，减少了元数据区域的频繁写入，从而降低了磁盘负载。

**快速崩溃恢复**

**1**    **快速恢复时间**：

o  在崩溃后的恢复过程中，文件系统只需要回放日志中的未完成事务，而不需要扫描和检查整个文件系统。日志的回放相对快速且高效，显著减少了系统恢复时间。

**2**    **数据一致性保证**：

o  事务性日志系统通过确保所有元数据更改在应用前都记录到日志中，提供了数据一致性的保证，减少了系统需要进行复杂一致性检查的频率。

**高效的缓存利用**

**1**    **缓存命中率高**：

o  由于日志的顺序写入和元数据的批量处理，系统可以更高效地利用缓存，减少磁盘I/O操作次数，从而提高整体性能。

 

记住xv6是先写入log block（写data或者元数据），再写header block（这里之后就可以crash recovery），最后再copy到正确位置。然后删除header block，此时系统调用才能返回。

 

搞清楚ext3要不要写data block进log里面。

linux上是可选的，一种是journaling data就是像xv6这样把metadata与data（即content）都写进log里面，这样非常直观但会慢（因为content和metadata还要写到实际位置）；另一种就是ordered data，只把metadata写进log里面，content就直接写到实际位置上，那么到时候只要写metadata到实际位置就行，可以省时间，更多是选择了后者。（在写入content之后写入metadata之前crash了，那么这些content就会被判定为垃圾，在一个新块上进行写入操作容易理解，它都没有inode这些元数据自然是被判断成垃圾块；但在一个旧块上进行写入操作的话，就会对比一下元数据是否合理什么的，从而知道这些content是垃圾，不予恢复）还有一种叫writeback。

 

describe block像xv6的header block，commit block对应于describe block，用来描述事务有没有结束，可见1:04，有一对才说明是一个完整的事务，他们各有一个magic number（32位），data block是0，这样子在recovery的时候软件就知道它是描述块还是数据块了。如果发生了约1:24时的情况，可见t5的commit block的magic number不是对应于t8的describe block的magic number，所以t8中的事务不会被恢复。

 

ext3更像是一个环，xv6的话如果超过了log范围的最大处，它就会先完成这些工作。但是ext3的话会回到log的最小处重新做事务工作，除非头部追上尾部（头尾由super block来存储这两个指针）



xv6与这个设计的差别是xv6只有一个事务，而ext3有多个，所以xv6得不到并发行，得不到async（即执行来自事务2的系统调用时，同时提交事务1的东西到磁盘上的真正位置，xv6的话就只能先1后2了）



## 课上内容

首先来回顾一下XV6的logging系统。我们有一个磁盘用来存储XV6的文件系统，你可以认为磁盘分为了两个部分：

 

首先是文件系统目录的树结构，以root目录为根节点，往下可能有其他的目录，我们可以认为目录结构就是一个树状的数据结构。假设root目录下有两个子目录D1和D2，D1目录下有两个文件F1和F2，每个文件又包含了一些block。除此之外，还有一些其他并非是树状结构的数据，比如bitmap表明了每一个data block是空闲的还是已经被分配了。

除了文件系统之外，XV6在磁盘最开始的位置还有一段log。XV6的log相对来说比较简单，它有header block，之后是一些包含了有变更的文件系统block，这里可以是metadata block也可以是data block。header block会记录之后的每一个log block应该属于文件系统中哪个block，假设第一个log block属于block 17，第二个属于block 29。

![img](assets\clip_image002-1729429903986-1.jpg)

在计算机上，我们会有一些用户程序调用write/create系统调用来修改文件系统。在内核中存在block cache，最初write请求会被发到block cache。block cache就是磁盘中block在内存中的拷贝，所以最初对于文件block或者inode的更新走到了block cache。在write系统调用的最后，这些更新都被拷贝到了log中，之后我们会更新header block的计数来表明当前的transaction已经结束了。在文件系统的代码中，任何修改了文件系统的系统调用函数中，某个位置会有begin_op，表明马上就要进行一系列对于文件系统的更新了，不过在完成所有的更新之前，不要执行任何一个更新。在begin_op之后是一系列的read/write操作。最后是end_op，用来告诉文件系统现在已经完成了所有write操作。所以在begin_op和end_op之间，所有的write block操作只会走到block cache中。当系统调用走到了end_op函数，文件系统会将修改过的block cache拷贝到log中。

在拷贝完成之后，文件系统会将修改过的block数量，通过一个磁盘写操作写入到log的header block，这次写入被称为commit point。在commit point之前，如果发生了crash，在重启时，整个transaction的所有写磁盘操作最后都不会应用。在commit point之后，即使立即发生了crash，重启时恢复软件会发现在log header中记录的修改过的block数量不为0，接下来就会将log header中记录的所有block，从log区域写入到文件系统区域。

 

这里有几个超级重要的点，不仅针对XV6，对于大部分logging系统都适用：

包括XV6在内的所有logging系统，都需要遵守write ahead rule。这里的意思是，任何时候如果一堆写操作需要具备原子性，系统需要先将所有的写操作记录在log中，之后才能将这些写操作应用到文件系统的实际位置。也就是说，我们需要预先在log中定义好所有需要具备原子性的更新，之后才能应用这些更新。write ahead rule是logging能实现故障恢复的基础。write ahead rule使得一系列的更新在面对crash时具备了原子性。

另一点是，XV6对于不同的系统调用复用的是同一段log空间，但是直到log中所有的写操作被更新到文件系统之前，我们都不能释放或者重用log。我将这个规则称为freeing rule，它表明我们不能覆盖或者重用log空间，直到保存了transaction所有更新的这段log，都已经反应在了文件系统中。

 

在XV6中，end_op做了大量的工作，首先是将所有的block记录在log中，之后是更新log header。在没有crash的正常情况，文件系统需要再次将所有的block写入到磁盘的文件系统中。磁盘中的文件系统更新完成之后，XV6文件系统还需要删除header block记录的变更了的block数量（因为我们不想在header block中记录的还是前一个transaction的信息，而log中记录的又是一个新的transaction的数据），以表明transaction已经完成了，之后就可以重用log空间。

XV6中的任何一个例如create/write的系统调用，需要在整个transaction完成之后才能返回。所以在创建文件的系统调用返回到用户空间之前，它需要完成所有end_op包含的内容，这包括了：

将所有更新了的block写入到log

更新header block

将log中的所有block写回到文件系统分区中

清除header block

之后才能从系统调用中返回。在任何一个文件系统调用的commit过程中，不仅是占据了大量的时间，而且其他系统调用也不能对文件系统有任何的更新。所以这里的系统调用实际上是一次一个的发生，而每个系统调用需要许多个写磁盘的操作。即sync，所以它非常非常慢。

 

ext3的数据结构与XV6是类似的。**在内存中**，存在block cache，这是一种write-back cache（注，区别于write-through cache，指的是cache稍后才会同步到真正的后端）。block cache中缓存了一些block，其中的一些是干净的数据，因为它们与磁盘上的数据是一致的；其他一些是脏数据，因为从磁盘读出来之后被修改过；有一些被固定在cache中，基于前面介绍的write-ahead rule和freeing rule，不被允许写回到磁盘中。

除此之外，ext3还维护了一些transaction信息。它可以维护多个在不同阶段的transaction的信息。**每个****transaction**的信息包含有（这些也是在内存中）：

一个序列号（magic number）

一系列该transaction修改的block编号。这些block编号指向的是在cache中的block，因为任何修改最初都是在cache中完成。

以及一系列的handles，handle对应了系统调用，并且这些系统调用是transaction的一部分，会读写cache中的block

 

在磁盘上，与XV6一样：

会有一个文件系统树，包含了inode，目录，文件等等

会有bitmap block来表明每个data block是被分配的还是空闲的

在磁盘的一个指定区域，会保存log（主要的区别在于ext3可以同时跟踪多个在不同执行阶段的transaction。）

 

在log（磁盘）的最开始，是super block。这是log的super block，而不是文件系统的super block。log的super block包含了log中第一个有效的transaction的起始位置和序列号。起始位置就是磁盘上log分区的block编号，序列号就是前面提到的每个transaction都有的序列号。log是磁盘上一段固定大小的连续的block。log中，除了super block以外的block存储了transaction。每个transaction在log中包含了：

一个descriptor block，其中包含了log数据对应的实际block编号，这与XV6中的header block很像。

之后是针对每一个block编号的更新数据。

最后当一个transaction完成并commit了，会有一个commit block

 

![img](assets\clip_image004-1729429903987-2.jpg)

在crash之后的恢复过程会扫描log，为了将descriptor block和commit block与data block区分开，descriptor block和commit block会以一个32bit的魔法数字作为起始。这个魔法数字不太可能出现在数据中，并且可以帮助恢复软件区分不同的block。

Log中会有多个transaction，但是的确一个时间只有一个正在进行的transaction。

 

ext3通过3种方式提升了性能：

首先，它提供了异步的（asynchronous）系统调用，也就是说系统调用在写入到磁盘之前就返回了，系统调用只会更新缓存在内存中的block，并不用等待写磁盘操作。不过它可能会等待读磁盘。

第二，它提供了批量执行（batching）的能力，可以将多个系统调用打包成一个transaction。

最后，它提供了并发（concurrency）。

 

首先是异步的系统调用。**这表示系统调用修改完位于缓存中的****block****之后就返回，并不会触发写磁盘。**所以这里明显的优势就是系统调用能够快速的返回。同时它也使得I/O可以并行的运行，也就是说应用程序可以调用一些文件系统的系统调用，但是应用程序可以很快从系统调用中返回并继续运算，与此同时文件系统在后台会并行的完成之前的系统调用所要求的写磁盘操作。这被称为I/O concurrency。另一个异步系统调用带来的好处是，它使得大量的批量执行变得容易。异步系统调用的缺点是系统调用的返回并不能表示系统调用应该完成的工作实际完成了。**（因为它用的是内存中的****block****，那些block****实际上可能还没写到磁盘中）**

 

下一个ext3使用的技术是批量执行（batching）。在任何时候，ext3只会有一个open transaction。ext3中的一个transaction可以包含多个不同的系统调用。所以ext3是这么工作的：它首先会宣告要开始一个新的transaction，接下来的几秒所有的系统调用都是这个大的transaction的一部分。我认为默认情况下，ext3每5秒钟都会创建一个新的transaction，所以每个transaction都会包含5秒钟内的系统调用，这些系统调用都打包在一个transaction中。在5秒钟结束的时候，ext3会commit这个包含了可能有数百个更新的大transaction。（好用的缘由见：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec16-file-system-performance-and-fast-crash-recovery-robert/16.4-ext3-ru-he-ti-sheng-xing-neng ）

 

ext3使用的最后一个技术就是concurrency，相比XV6这里包含了两种concurrency。

首先ext3允许多个系统调用同时执行，所以我们可以有并行执行的多个不同的系统调用。在ext3决定关闭并commit当前的transaction之前，系统调用不必等待其他的系统调用完成，它可以直接修改作为transaction一部分的block。许多个系统调用都可以并行的执行，并向当前transaction增加block，这在一个多核计算机上尤其重要，因为我们不会想要其他的CPU核在等待锁。在XV6中，如果当前的transaction还没有完成，新的系统调用不能继续执行。而在ext3中，大多数时候多个系统调用都可以更改当前正在进行的transaction。

另一种ext3提供的并发是，可以有多个不同状态的transaction同时存在。所以尽管只有一个open transaction可以接收系统调用，但是其他之前的transaction可以并行的写磁盘。这里可以并行存在的不同transaction状态包括了：

首先是一个open transaction

若干个正在commit到log的transaction，我们并不需要等待这些transaction结束。当之前的transaction还没有commit并还在写log的过程中，新的系统调用仍然可以在当前的open transaction中进行。

若干个正在从cache中向文件系统block写数据的transaction

若干个正在被释放的transaction，这个并不占用太多的工作

通常来说会有位于不同阶段的多个transaction，新的系统调用不必等待旧的transaction提交到log或者写入到文件系统。对比之下，XV6中新的系统调用就需要等待前一个transaction完全完成。

 

ext3的系统调用的结构：

在Linux的文件系统中，我们需要每个系统调用都声明一系列写操作的开始和结束（像xv6的beginop和endop）。实际上在任何transaction系统中，都需要明确的表示开始和结束，这样之间的所有内容都是原子的。所以系统调用中会调用start函数。ext3需要知道当前正在进行的系统调用个数，所以每个系统调用在调用了start函数之后，会得到一个handle，它某种程度上唯一识别了当前系统调用。当前系统调用的所有写操作都是通过这个handle来识别跟踪的。

之后系统调用需要读写block，它可以通过get获取block在buffer中的缓存，同时告诉handle这个block需要被读或者被写。如果你需要更改多个block，类似的操作可能会执行多次。之后是修改位于缓存中的block。

当这个系统调用结束时，它会调用stop函数，并将handle作为参数传入。除非transaction中所有已经开始的系统调用都完成了，transaction是不能commit的。因为可能有多个transaction，文件系统需要有种方式能够记住系统调用属于哪个transaction，这样当系统调用结束时，文件系统就知道这是哪个transaction正在等待的系统调用，所以handle需要作为参数传递给stop函数。

![img](assets\clip_image006-1729429903987-3.jpg)

stop函数并不会导致transaction的commit，它只是告诉logging系统，当前的transaction少了一个正在进行的系统调用。transaction只能在所有已经开始了的系统调用都执行了stop之后才能commit。所以transaction需要记住所有已经开始了的handle，这样才能在系统调用结束的时候做好记录。

 

commit transaction完整的步骤：

每隔5秒，文件系统都会commit当前的open transaction，下面是commit transaction涉及到的步骤：

 

1首先需要阻止新的系统调用。当我们正在commit一个transaction时，我们不会想要有新增的系统调用，我们只会想要包含已经开始了的系统调用，所以我们需要阻止新的系统调用。这实际上会损害性能，因为在这段时间内系统调用需要等待并且不能执行。

 

2第二，需要等待包含在transaction中的已经开始了的系统调用们结束。所以我们需要等待transaction中未完成的系统调用完成，这样transaction能够反映所有的写操作。

 

3一旦transaction中的所有系统调用都完成了，也就是完成了更新cache中的数据（就用上cache的最新内容），那么就可以开始一个新的transaction，并且让在第一步中等待的系统调用继续执行。所以现在需要为后续的系统调用开始一个新的transaction。

 

4还记得ext3中的log包含了descriptor，data和commit block吗？现在我们知道了transaction中包含的所有的系统调用所修改的block，因为系统调用在调用get函数时都将handle作为参数传入，表明了block对应哪个transaction。接下来我们可以更新descriptor block，其中包含了所有在transaction中被修改了的block编号。

 

5我们还需要将被修改了的block，从缓存中写入到磁盘的log中。之前有同学问过，新的transaction可能会修改相同的block，所以在这个阶段，我们写入到磁盘log中的是transaction结束时，对于相关block cache的拷贝。所以这一阶段是将实际的block写入到log中。

 

6接下来，我们需要等待前两步中的写log结束。

 

7之后我们可以写入commit block。

 

8接下来我们需要等待写commit block结束。结束之后，从技术上来说，当前transaction已经到达了commit point，也就是说transaction中的写操作可以保证在面对crash并重启时还是可见的。如果crash发生在写commit block之前，那么transaction中的写操作在crash并重启时会丢失。

 

9接下来我们可以将transaction包含的block写入到文件系统中的实际位置。

 

10在第9步中的所有写操作完成之后，我们才能重用transaction对应的那部分log空间。

 

在一个非常繁忙的系统中，log的头指针一直追着尾指针在跑（注，也就是说一直没有新的log空间）。在当前最早的transaction的所有步骤都完成之前，或许不能开始commit一个新的transaction，因为我们需要重复利用最早的transaction对应的log空间。不过人们通常会将log设置的足够大，让这种情况就不太可能发生。

![img](assets\clip_image008-1729429903987-5.jpg)

ext3 file system恢复过程：

当决定释放某段log空间时，文件系统会更新super block中的指针将其指向当前最早的transaction的起始位置。（头部）

之后如果crash并重启，恢复软件会读取super block，并找到log的起始位置。

crash或许会打断任何在进行中的transaction，或许transaction正在commit，或许transaction正在向文件系统写block。让我重新画一个例子，我们在log中有一个super block，之后是transaction T6，T7，T8，在T8之后是一个已近被释放了log空间的T5，假设T8已经用了T5的一部分空间。并且现在super block指向的是T6的起始位置，因为T6是最早的transaction。

![img](assets\clip_image010-1729429903987-4.jpg)

现在crash并重启，恢复软件读取super block就可以知道log的起始位置，之后恢复软件会在log中一直扫描并尝试找到log的结束位置，现在我们需要有一种方式确定log的结束位置。我们知道每个transaction包含了一个descriptor block，里面记录了该transaction中包含了多少个data block，假设descriptor block记录了17个block，那么恢复软件会扫描17个data block，最后是commit block。这样可以一直扫描到T8。

 

在扫描T8时有两种可能，一种可能是T8完成了commit，并且包含了commit block。这时恢复软件并不知道T8就是最后一个transaction，所以它会接着看T8的commit block的下一个block，来看看这是不是一个有效的descriptor block。我们知道这不是一个descriptor block，而是一个包含在T5内的随机block。现在的问题是恢复软件如何可靠的区分出来呢？是的，每个descriptor和commit block都以某个魔法数字作为起始，这是一个32bit的数字。所以如果扫描完了T8，下一个block以魔法数字作为起始，那么恢复软件就会认为这是一个descriptor block。（如果是0就是datablock，就明白T8是最后一个事务了）。另一种T8没完成commit，都没有commit block，那事务自然是不完整的，t8不予恢复。还有一种特殊情况，t5释放到一半，commit block(5)还没有释放完，t8也只写到一半，只有descriptor block(8)，即T8有一个假的commit block，但8与5都没对上（即魔法数字没对上）所以t8的处理的情况与第二种相同。

所以恢复软件会从super block指向的位置开始一直扫描，直到：

某个commit block之后的一个block并不是descriptor block

或者某个commit block之后是descriptor block，但是根据descriptor block找到的并不是一个commit block

 

XV6主要缺失的是在log中包含多个transaction的能力，在XV6的log中最多只会有一个transaction，所以在XV6中缺少了并发的能力。比如说当我在执行transaction T7的系统调用时，ext3可以同时向磁盘提交T6，而这在XV6中这是不可能的，因为log只保存了一个transaction。所以我们必须先完成一个transaction的所有工作，之后才能开始下一个transaction。

XV6实际上允许在一个transaction中包含多个系统调用（注，详见15.8），所以XV6有一些并发和batching的能力，但是当XV6决定要commit一个transaction时，在完全完成这个transaction之前，是不能执行任何新的系统调用的。因为直到前一个transaction完全完成，并没有log空间来存放新的系统调用。所以XV6要么是在运行一些系统调用，要么是在commit transaction，但是它不能同时干这两件事情，而ext3可以同时干这两件事情。（在上面的第三步里面，等到当前事务的系统调用完成时就能执行新的系统调用了，因为它又新开了一个事务，而xv6做不到，因为没有空间）

 

解释一下第三步，为什么新事务要等到前一个事务中的系统调用完成？

如果我们想要关闭T1，我们需要停止接收新的系统调用，因为我们想要等待现有的系统调用结束，这样才能commit transaction。所以直到这些系统调用都结束了，在ext3中不能允许开始任何新的系统调用。所以只有在T1中的系统调用完成之后，才能开始在接下来的transaction T2中接收系统调用。在这之间有一段时间，新的系统调用是被拦截的，这降低了性能，因为我们本来应该执行系统调用的但是又不被允许。

![img](assets\clip_image012-1729429903987-6.jpg)

让我们来看一下没有这个限制条件可能会带来的错误的场景。我们假设T1只包含了一个系统调用，这是一个create系统调用用来创建文件x。在create系统调用结束之前，文件系统决定开始一个新的transaction T2用来接收create之后的所有系统调用。我们假设T2在T1结束之前就开始了，T2对另一个文件y调用了unlink系统调用。unlink会释放与y关联的inode。

![img](assets\clip_image014-1729429903987-7.jpg)

因为create在unlink释放inode之后分配的inode，它可能会重用同一个inode，所以x可能会获得y的inode，假设是inode 17。目前为止没有问题，因为unlink本来就是释放inode。当T1中的create结束之后，我们会关闭T1，在最后我们会将T1的所有更新都写入到磁盘的log中。之后unlink还要花点时间才能结束，但是在它结束之前计算机crash了。

 

 

![img](assets\clip_image016-1729429903987-8.jpg)

需要记住的有关logging和ext3的是：

log是为了保证多个步骤的写磁盘操作具备原子性。在发生crash时，要么这些写操作都发生，要么都不发生。这是logging的主要作用。

 

logging的正确性由write ahead rule来保证。你们将会在故障恢复相关的业务中经常看到write ahead rule或者write ahead log（WAL）。write ahead rule的意思是，你必须在做任何实际修改之前，将所有的更新commit到log中。在稍后的恢复过程中完全依赖write ahead rule。对于文件系统来说，logging的意义在于简单的快速恢复。log中可能包含了数百个block，你可以在一秒中之内重新执行这数百个block，不管你的文件系统有多大，之后又能正常使用了。

 

最后有关ext3的一个细节点是，它使用了批量执行和并发来获得可观的性能提升，不过同时也带来了可观的复杂性的提升。