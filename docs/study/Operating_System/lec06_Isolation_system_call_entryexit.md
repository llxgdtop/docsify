## 课前内容

在trampoline.s内容中

uservec标签处的代码用于从用户空间陷入内核空间。当发生中断或异常时,处理器会从用户空间跳转到这里。它的主要工作是:首先交换a0和sscratch寄存器,使a0指向TRAPFRAME内存区域。然后它保存所有用户寄存器的值到TRAPFRAME中。接着,它从TRAPFRAME中恢复内核栈指针和hartid,加载usertrap()函数的地址,切换到内核页表,最后跳转到usertrap()函数。

保存用户寄存器的值到TRAPFRAME内存区域。

恢复内核栈指针和hartid(硬件线程ID)。

切换到内核页表。

跳转到usertrap()函数,进入内核异常处理流程。

到65行为止，所有的用户寄存器都保存完毕。除此之外，trapframe里面还保存了一些与内核信息相关的指针，现在将它们恢复出来，包括内核栈指针，CPUid，内核页表，以及usertrap的位置。值得注意的是，在我们加载内核页表到satp之后，a0就无效了，因为trapframe只映射在用户虚拟地址空间内，所以我们之前就把usertrap的位置加载到t0，并在最后跳转到t0。

 

userret标签处的代码用于从内核空间返回到用户空间。它的主要工作是:首先切换到用户页表。然后,它将用户a0的值保存到sscratch寄存器中。接着,它从TRAPFRAME恢复所有用户寄存器的值(除了a0)。最后,它使用csrrw指令恢复用户a0,并将TRAPFRAME的地址保存到sscratch中。最后,使用sret指令返回到用户模式,并恢复用户PC。

切换到用户页表。

从TRAPFRAME恢复用户寄存器值。

使用sret指令,返回到用户模式并恢复用户PC(程序计数器)。

 

以ld ra，40(a0)为例子，40是一个立即数(immediate),表示一个内存偏移量。从内存地址a0 + 40处加载一个双字(8字节)的值,并将其存储到寄存器ra中。40(a0)表示TRAPFRAME内存区域中偏移40字节的位置,这个位置存储了之前保存的ra寄存器值。

ld指令:

全称是load double word

作用是从内存加载一个双字(8字节,64位)的数据到寄存器中

例如ld x10, 8(x12)表示从内存地址[x12+8]处加载一个双字,并将其存储到寄存器x10中

sd指令:

全称是store double word

作用是将寄存器中的一个双字(8字节,64位)的数据存储到内存中

例如sd x10, 8(x12)表示将寄存器x10中的值存储到内存地址[x12+8]处

lw(load word,加载字,4字节)、sw(store word,存储字,4字节)等,用于处理32位数据。

定时器中断在xv6中扮演着极其重要的角色,主要有以下作用:

实现进程的时间片轮转调度。通过周期性地触发调度,防止单个进程长时间占用CPU。

提供系统时钟,用于实现sleep等需要时间参数的系统调用。

产生操作系统的"心跳",驱动整个系统的运行。

总之,定时器中断是操作系统内核的"脉搏",确保了进程的公平调度、时间服务的提供,以及整个系统的连续运转。

 

在xv6中,设备中断包括以下两种类型:

外部中断(Supervisor External Interrupt)

外部中断是由外部设备通过可编程中断控制器(PLIC，在pgtbl中lab有提到过)发出的中断请求。在devintr函数中,通过检查scause寄存器的最高位是否为1,以及中断原因码是否为9,来判断是否为外部中断。

软件中断(Software Interrupt)

软件中断是由软件主动触发的中断,通常用于处理一些异步事件。在xv6中,软件中断主要用于处理计时器中断。在devintr函数中,通过检查scause寄存器的值是否为0x8000000000000001L来判断是否为软件中断。

 

设备中断指的是由外部硬件设备(如硬盘、网卡、UART等)发出的中断请求信号,用于通知CPU有来自外设的事件需要处理。在xv6中,设备中断被称为"外部中断"(Supervisor External Interrupt)。

定时器中断则是由系统硬件定时器产生的周期性中断,主要用于实现进程调度、提供系统时钟等功能。在xv6中,定时器中断被称为"软件中断"(Software Interrupt),因为它是由软件主动触发的。

两者的区别主要有:

1触发源不同

设备中断由外部硬件设备触发

定时器中断由系统内部的硬件定时器触发

2中断传递方式不同

设备中断通过可编程中断控制器(PLIC)传递给CPU

定时器中断通过软件中断的方式传递给CPU

3处理方式不同

设备中断需要调用相应的设备驱动程序进行处理

定时器中断主要是更新系统时钟,并决定是否需要进行进程调度

4作用不同

设备中断用于响应外设事件,保证与外设的正常通信

定时器中断用于维护系统时钟,实现进程调度等系统功能

 

中断(interrupt)和异常(exception)在操作系统中都是指导致CPU暂停当前执行的程序并转而执行另一段代码的事件,但它们有一些重要区别:

1触发源不同

中断通常由CPU外部的硬件设备触发,如时钟、磁盘、网卡等。

异常通常由CPU内部的软件条件触发,如非法内存访问、除零错误等。

2异步性

中断是异步的,可以在任何时候发生,与当前执行的程序无关。

异常是同步的,是由当前执行的程序的指令导致的。

3发生原因

中断通常表示需要CPU处理某个事件,如设备输入/输出操作完成。

异常通常表示程序出现了错误,如非法内存访问等。

4可掩码性

中断通常是可以被屏蔽(masked)的,CPU可以选择暂时忽略某些中断源。

异常通常是不可屏蔽的,一旦发生就必须立即处理。

5返回方式

中断处理程序通常在完成后直接返回到被中断的程序继续执行。

异常处理程序可能需要终止或重新启动出错的程序。

 

PLIC是Platform-Level Interrupt Controller的缩写,是RISC-V架构中用于管理中断的硬件模块。

在RISC-V系统中,PLIC负责接收来自各种外部设备的中断请求,并将中断信号传递给CPU核心。它充当了外设和CPU之间的中断控制器,实现了中断的集中管理和分发。

PLIC的主要功能包括:

1中断源编号:PLIC为每个连接的外设分配一个中断源编号(Interrupt Source ID),用于唯一标识该设备的中断。

2中断优先级:PLIC允许为每个中断源设置不同的优先级,以确定中断处理的先后顺序。

3中断屏蔽:PLIC可以屏蔽(mask)特定的中断源,使CPU暂时忽略这些中断。

4中断寄存器:PLIC包含一些寄存器,用于设置中断源的属性、优先级以及读取中断挂起状态等。

5中断请求传递:当外设发出中断请求时,PLIC会将对应的中断信号传递给CPU核心,并提供中断原因码(Cause Code)供CPU识别中断源。

在xv6操作系统中,PLIC主要通过以下几个函数进行管理:

plic_init函数用于初始化PLIC,设置中断优先级等。

plic_claim函数用于获取当前最高优先级的中断源编号。

plic_complete函数用于通知PLIC已经处理完该中断源,允许其再次发出中断请求。

 

CPU通常有三种特殊事件会暂停当前指令流的执行，并跳转到一段特定代码来处理这些事件。系统调用，执行RISC-V的ecall指令时。异常，用户或内核指令可能进行了一些非法操作，例如除以0或者使用无效的虚拟地址时。设备中断，当一个设备因某些原因（如磁盘的读/写工作完成）需要CPU及时处理时。CPU暂停当前指令流执行，跳转到一段特定代码去处理特殊事件的情况，我们称为陷阱trap。



### Traps from user space

以在用户空间下发生trap为例，通常的流程是，trap会强制地从用户空间切换到内核空间。在内核空间下，内核保存一些寄存器和其它状态，以便稍后恢复执行被暂停的进程指令流。然后内核就开始执行一段特定的处理代码（如系统调用函数、设备驱动程序等）。处理完毕后，内核就恢复之前保存的寄存器和其它进程状态，最后从内核空间返回到用户空间，恢复执行之前被暂停的用户指令流。trap最好是对用户进程透明的，即保存和恢复相关寄存器应该由内核负责而不让用户来操心，从trap返回时也应该回到进程指令流被中止的位置，用户进程应该感受不到trap的发生。trap所经历的完整流程，从代码路径来看就是：uservec→usertrap→usertrapret→userret。具体经过见xv6代码手册：

https://zhuanlan.zhihu.com/p/351939252 ;

uservec：位于trampoline的前半部分汇编代码，用于做一些陷入内核之前的准备工作，例如保存用户空间下的一系列寄存器，加载内核栈、内核页表等设置，然后跳转到usertrap。这一部分，我们称为trap vector。

usertrap：位于内核中的一段C代码，判断引起trap的事件类型，并决定如何处理该trap，如跳转到系统调用函数、设备驱动程序等。我们一般也称其为trap handler。trap vector是trap handler的准备部分。

usertrapret：位于内核中的另一段C代码，trap被处理完之后，就会跳转到usertrapret，保存内核栈、内核页表等内核相关信息，进行一些设置，然后跳转到userret。

userret：位于trampoline的后半部分汇编代码，用于做一些返回用户空间的恢复工作，恢复之前保存的用户空间寄存器，最后返回用户空间，恢复用户进程指令流的执行。

 

stvec：内核将trap handler（在用户空间下的trap，是trampoline的uservec；在内核空间下的trap，是kernel/kernelvec.S中的kernelvec）写到stvec中。当trap发生时，RISC-V就会跳转到stvec中的地址，准备处理trap。你可能发现，被写入stvec的是uservec或者kernelvec，而不是usertrap，其实我们也可以将两个trap vector认为是trap handler的准备工作部分。

sepc：当trap发生时，RISC-V就将当前pc的值保存在sepc中（例如，指令ecall就会做这个工作），因为稍后RISC-V将使用stvec中的值来覆盖pc，从而开始执行trap handler。稍后在userret中，sret指令将sepc的值复制到pc中，内核可以设置sepc来控制sret返回到哪里。

scause：RISC-V在这里存放一个数字，代表引发trap的原因。

sscratch：一个特别的寄存器，通常在用户空间发生trap，并进入到uservec之后，sscratch就装载着指向进程trapframe的指针（该进程的trapframe，在进程被创建，并从userret返回的时候，就已经被内核设置好并且放置到sscratch中）。RISC-V还提供了一条交换指令（csrrw），可以将任意寄存器与sscratch进行值的交换。sscratch的这些特性，便于在uservec中进行一些寄存器的保存、恢复工作。

sstatus：位于该寄存器中的SIE位，控制设备中断是否开启，如果SIE被清0，RISC-V会推迟期间的设备中断，直到SIE被再次置位；SPP位指示一个trap是来自用户模式下还是监管者模式下的，因此也决定了sret要返回到哪个模式下。

以上这些控制寄存器不能在用户模式下访问，只有在内核中，在监管者模式下处理trap时，才能访问或设置这些寄存器。值得一提的是，机器模式下也有完全对等的一系列控制寄存器，不同的是这些寄存器以m开头命名，而且只有在机器模式下处理trap时，才能用到它们。在xv6中，只有计时器中断这一特殊情况会用到机器模式下的控制寄存器。

 

当trap确实发生了，RISC-V CPU硬件按以下步骤处理所有类型的trap（除了计时器中断）：

1如果造成trap的是设备中断，将sstatus中的SIE位清0，然后跳过以下步骤。

2（如果trap的原因不是设备中断）将sstatus中的SIE位清0，关闭设备中断。

3将pc的值复制到sepc中。

4将发生trap的当前模式（用户模式或监管者模式）写入sstatus中的SPP位。

5设置scause的内容，反映trap的起因。

6设置模式为监管者模式。

7将stvec的值复制到pc中。

8从新的pc值开始执行。

值得注意的是，当trap发生了之后，硬件做的事情实际上很少，CPU没有切换到内核页表，没有切换到内核栈，也没有保存任何的寄存器（除了PC）。因此，内核中的代码必须完成以上这些工作。让CPU完成尽可能少的工作，其中一个原因是为内核代码提供灵活性。例如，一些操作系统在trap发生之后可能并不需要切换页表（在它们的设计里，用户空间和内核空间使用同一个页表，按照例如用户空间在低地址，内核空间在高地址等方式设计），如果我们的内核可以自己选择不切换页表，就省去了相关操作，从而提升了性能。

 

在trap发生时，RISC-V硬件并不会切换页表，因此，用户页表应该包含uservec的映射。

内核使用argint、argaddr和argfd等函数，来抽取出用户参数值，并把它作为整数、指针或者文件描述符。它们都利用argraw（就是那个switch函数，返回的是a0，a1...的值）这个函数来抽取相应参数。

一些系统调用会传递指针作为用户参数，内核必须使用这些指针，读或写这些属于用户进程的物理内存。例如，exec就给内核传递了一个argv指针，指向一系列的命令行参数。但指针可能是无效的或者是恶意的。不过可以用fetchar来安全地从用户地址中复制内容到内核缓冲区中。fetchstr将主要的工作交给copyinstr来完成。

copyinstr（kernel/vm.c）的作用是，给定一个用户页表，从用户虚拟地址srcva（例如用户缓冲区），安全地拷贝最多max个字节到内核的dst位置中。首先copyinstr调用walkaddr来为srcva找到对应的物理地址pa0，利用内核采用直接映射的特性，我们将pa0作为虚拟地址，便可以直接地从pa0中拷贝字节流到dst中。现在，用户将无法传递一个尝试访问内核的物理内存的指针，因为walkaddr会检查该地址是否在用户虚拟地址空间中。因此，一个尝试访问内核物理内存的非法访问，显然不会出现在用户页表的映射项里，walkaddr会返回失败，从而不让恶意的用户进程得逞。同理，尝试访问其它用户进程的物理内存的指针也不会通过walkaddr的严格检查。



### Traps from kernel space

具体步骤也可见上方链接。

 

计时器中断在机器模式下处理。在xv6的启动阶段中，仍处于机器模式下，在机器模式下我们通过timerinit（kernel/start.c）初始化了计时器，CLINT将负责产生计时器中断，更重要的是，我们通过改写mtvec寄存器的值（和stvec类似）将机器模式下的trap handler设置为timervec。因此，当CLINT产生一个计时器中断时，硬件会自动陷入机器模式，并跳转到timervec开始处理。timervec主要做的事情就是对计时器芯片重新编程，使其开始新的一轮计时，并且产生向监管者模式发出一个软件中断。最后，timervec通过mret返回监管者模式下，如果在监管者模式下，我们的中断是开放的，那么内核就能够捕捉到这个软件中断，内核会跳转到kernelvec，保存相关寄存器，然后在kerneltrap中，发现这是一个设备中断而且是计时器中断，从而执行相应的处理。

 

trampoline是一小段内核程序,被映射到用户地址空间的最高地址处。当需要从用户态进入内核态时,CPU先跳转到trampoline执行,trampoline会完成这些必要的切换操作,最后跳转到内核的实际处理程序。其中的操作是指：

1保存用户态下的寄存器上下文（通过结构体trapframe，保存执行现场的数据结构就称为trapframe）

将通用寄存器(包括程序计数器PC等)的值保存到内核为该进程分配的内核栈中。

2切换到内核态

通过特权指令,将CPU从用户态切换到内核态执行。

关闭分页机制,加载内核的页表基址到satp寄存器。

设置内核栈指针到对应进程的内核栈。

3加载内核处理程序入口

将内核的系统调用或异常处理程序的入口地址加载到PC寄存器。

4其他必要设置

根据需要,设置内核临时栈、内核线程ID等CPU状态。

 

当处于用户态时发生trap(如系统调用或异常)时,CPU会执行以下流程切换到内核态并处理trap:

1保存用户态现场

CPU硬件会触发trap,将当前用户态执行的现场(PC、通用寄存器等)自动保存到指定的trampoline代码段(由stvec寄存器指定)。

2trampoline代码执行

trampoline是一段汇编代码,用于从用户态切换到内核态执行。

trampoline首先在内核为该进程分配的内核栈上,分配一个trapframe结构体空间。

然后将之前硬件自动保存的部分现场,以及其余所有通用寄存器（比如x0-x31这些没被保存）的值,全部保存到trapframe结构体中（这部分通过汇编程序来完成）。

保存完成后,trampoline切换CPU到内核态,加载内核页表satp,设置内核栈指针等。

3跳转到内核trap处理函数

trampoline最后跳转到内核的trap入口点,如xv6中的usertrap()函数。

usertrap()函数根据trap的具体原因码,分发到相应的处理例程,如syscall()处理系统调用。

4内核处理trap

内核trap处理例程使用trapframe中保存的寄存器值,获取系统调用参数或异常信息。

执行相应的内核功能,如读写文件、创建进程等。

操作完成后,trap处理例程准备返回用户态执行。

5恢复用户态现场

内核trap处理例程调用usertrapret()函数。保存内核栈、内核页表等内核相关信息，进行一些设置，然后跳转到userret。它从trapframe结构体中,重新加载所有之前保存的寄存器值到CPU寄存器。

最后通过设置stvec和kernel_trap两个向量,让CPU从trampoline代码段的"出口"分支执行。

6trampoline出口

trampoline出口分支执行一些"反向"操作,如关闭内核页表映射,切换回用户态等。

最后从trapframe中恢复用户态的PC值,使CPU在用户空间继续执行。



## 课上内容

![img](assets\clip_image002-1729267222901-1.jpg)

ecall并不会切换page table，所以这意味着，trap处理代码必须存在于每一个user page table中。因为ecall并不会切换page table，我们需要在user page table中的某个地方来执行最初的内核代码。这个trampoline page，是由内核小心的映射到每一个user page table中，以使得当我们仍然在使用user page table时，内核在一个地方能够执行trap机制的最开始的一些指令。（但用户代码不能写它，因为这些page对应的PTE并没有设置PTE_u标志位。这也是为什么trap机制是安全的。)

ecall实际上只会改变三件事情：

第一，ecall将代码从user mode改到supervisor mode。

第二，ecall将程序计数器的值保存在了SEPC寄存器。我们可以通过打印程序计数器看到这里的效果，

尽管其他的寄存器还是还是用户寄存器，但是这里的程序计数器明显已经不是用户代码的程序计数器。这里的程序计数器是从STVEC寄存器拷贝过来的值（处理trap的地址）。我们也可以打印SEPC（Supervisor Exception Program Counter）寄存器，这是ecall保存用户程序计数器的地方（发生trap的用户程序）。

第三，ecall会跳转到STVEC寄存器指向的指令。

 

当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？

 

Robert教授：在内核前一次切换回用户空间时，内核会执行set sscratch指令，将这个寄存器的内容设置为trapframe page的虚拟地址。所以，当我们在运行用户代码，比如运行Shell时，SSCRATCH保存的就是指向trapframe的地址。之后，Shell执行了ecall指令，跳转到了trampoline page，这个page中的第一条指令会交换a0和SSCRATCH寄存器的内容。所以，SSCRATCH中的值，也就是指向trapframe的指针现在存储与a0寄存器中。a0是如何有trapframe page的地址?查看trap.c代码，这是内核返回到用户空间的最后的C函数。C函数做的最后一件事情是调用fn函数，传递的参数是TRAMFRAME和user page table。所以a0就存有这个地址。

 

为什么这些寄存器保存在trapframe，而不是用户代码的栈中？这个问题的答案是，我们不确定用户程序是否有栈，必然有一些编程语言没有栈，对于这些编程语言的程序，Stack Pointer不指向任何地址。当然，也有一些编程语言有栈，但是或许它的格式很奇怪，内核并不能理解。

 

trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。

 

这里向trapframe中的a0赋值的原因是：所有的系统调用都有一个返回值，比如write会返回实际写入的字节数，而RISC-V上的C代码的习惯是函数的返回值存储于寄存器a0，所以为了模拟函数的返回，我们将返回值存储在trapframe的a0中。之后，当我们返回到用户空间，trapframe中的a0槽位的数值会写到实际的a0寄存器，Shell会认为a0寄存器中的数值是write系统调用的返回值。

 

在usertrap中，XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。之后到usertrapret中，它首先关闭了中断。我们之前在系统调用的过程中是打开了中断的，这里关闭中断是因为我们将要更新STVEC寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码（6.6）。我们关闭中断因为当我们将STVEC更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，出于各种各样具体细节的原因，这会导致内核出错。

 

用户寄存器（User Registers）必须在汇编代码中保存，因为任何需要经过编译器的语言，例如C语言，都不能修改任何用户寄存器。所以对于用户寄存器，必须要在进入C代码之前在汇编代码中保存好。但是对于SEPC寄存器（注，控制寄存器），我们可以早点保存或者晚点保存，比如在trampoline.s中就保存了。

sfence.vma是清空页表缓存



## labs内容

### RISC-V assembly

内联函数（Inline function）是一种特殊的函数，它在编译时会被展开在每个调用点，而不是像普通函数那样进行调用。这意味着编译器会将内联函数的代码直接复制到函数被调用的地方，而不是生成用于调用函数的代码。这样做的目的主要是为了减少函数调用的开销，提高程序的执行效率。

在C++中，可以通过在函数声明或定义前加上 inline 关键字来指定一个函数为内联函数，如：

inline int add(int a, int b) {

  return a + b;

}

在asm文件中可以看到类似于以下：0: 1141 是汇编语言中的一行代码的表示方式，其中：

0: 是这行指令的地址（或称为偏移量）。在这里，0 表示这是函数起始处的第一条指令。即这是一个标号（或称为标签），在机器代码中相当于这条指令的安置位置，它就是pc

1141 是该指令的机器码，即实际存储在计算机内存中用于表示该指令的二进制值在汇编时转化为对应的十六进制表示。

 

函数printf位于哪个地址？

答： 可以通过计算得到：

----auipc ra,0x0代表将当前立即数向左移动12位，然后加上pc寄存器的值，赋给ra寄存器。由于立即数为0，因此ra的值即为pc的值0x30。（因为前面是30: 00000097，30就是pc值）

----jalr 1510(ra)代表1536加上ra寄存器的值，然后赋值给pc。将1510转为16进制再加上0x30即为0x0000000000000616，也就是要跳转到printf的地址。

----也可以在汇编文件中去查找，直接在call.asm里面搜616就能查出来为printf地址。

 在jalr到main中的printf之后，寄存器ra中有什么值？

答： ra寄存器用来保存函数执行以后的下一条指令的地址，因此ra寄存器应当存放从printf返回main函数的地址，为0x38。

以一个四字节的无符号整数 0x12345678 为例，其在内存中的存储情况如下：

小端格式：

低地址 ------------------------> 高地址

0x78 | 0x56 | 0x34 | 0x12

大端格式：

0x12 | 0x34 | 0x56 | 0x78

所以0x00646c72在riscv中的内存存储情况为0x72  0x6c  0x64  0x00，故printf会开始打印直到遇到空终止符0x00为之，0x72对应的ascii码为r，别的同理。

printf("x=%d y=%d", 3);对于 y，因为没有提供第二个整数，printf 将尝试从调用者提供的参数中取得下一个值。由于参数的个数少于格式字符串中指定的数量，这将导致未定义行为。实际上，这通常意味着 printf 会从调用函数的栈上尝试读取下一个参数的值，这个值可能是任意的，取决于当前栈上该位置的内容，可能是内存中的任何值也可能是寄存器中的值。



### Backtrace

*(uint64*)(fp-8) 意味着“读取位于 fp-8 地址处的那个 uint64 类型的值”。(通过 (uint64*) 将计算出的地址强制转换为指向 uint64 类型的指针,之后，对转换后的指针使用解引用操作符 *，这表示我们想读取该指针指向的内存位置的值)

为什么不能直接使用fp-8，是因为fp – 8只是计算了一个新的地址（一个数值），并没有尝试访问这个地址处的数据。直接写fp-8相当于表示一个地址值，而不是去获取该地址处的内容。我们想要的是访问那个内存地址并读取存储在那里的值（这里假定是函数的返回地址）。

fp只是一个uint64，要用%p就要把fp转成一个指针，就使用符号强转(uint64*),况且我要的是return address，而不是地址，要的是地址里面的内容，所以要加一个解应用。

xv6中用一个页来存储栈，且向低地址扩展，所以当fp到达最高地址时说明到达栈底。（故循环终止条件是fp < PGROUNDUP(fp)）可以看lec5的stack图，一个stack包含了很多个stack frame。



### Alarm

sysproc.c都是在内核中执行的函数

这个新增功能旨在让操作系统能够定期地通知（提醒）正在使用 CPU 时间的进程。

"时钟中断"是一个相对宽泛的概念，它可以包括定时器中断和其他类型的时钟相关中断。但在lab中一般就是指定时器中断。

如果tick没达到设定的间隔，则tick++，若达到了则将tick清零，同时转去相应的处理程序handler。此处主要考虑如何调用处理函数handler。在usertrap中页表已经切换为内核页表，而handler仍然是用户页表的函数虚拟地址，因此不能直接调用。这里我们将p->trapfram->epc置为p->handler，这样在返回到用户空间时，程序计数器为handler定时函数的地址，便达到了执行定时函数的目的。(这里做的其实就是在内核态进行赋值，返回到用户态再执行。

test1/test2看一下 https://blog.csdn.net/InnerPeaceHQ/article/details/126117578 ；

①首先会调用系统调用sys_sigalarm。在调用之前，把所有的寄存器信息保存在了trapframe中。

②然后进入内核中执行sys_sigalarm函数。在执行的过程中只需要做一件事：为警报处理相关字段(如ticks、interval)进行赋值。

③赋值完成后，该sys_sigalarm系统调用就完成了。trapframe中保存的寄存器的值恢复，然后返回到用户态。(此时的trapframe没有保存的必要)

④在用户态中，每经历一次时钟中断(在trap.c中处理)就去对比ticks是否达到了规定的interval。如果达到了规定的interval，将返回地址(epc)更改为handler函数，返回用户态后便开始执行handler函数。

⑤执行完handler后，我们希望返回到调用handler前的状态。然而调用handler之前，返回地址epc已经被覆盖了。同时，执行handler后寄存器状态也会发生变化。

⑥因此，需要在handler覆盖掉epc之前需要保存好相应的寄存器状态

 

由于struct trapframe结构体只有288B，而一个页面是4096B，可以看到有大量内存空间未被使用。于是可以创建一个struct trapframecopy，让其与struct trapframe共用一个页面。仅需要新增一个指针指向struct trapframecopy，将该指针指向的位置指定为trapframe+512的地址即可(为了对齐)。同时要保存相同内容，就可以用memmove函数（这是复制而不是移动）。

对于“防止对警报处理程序handler的重入调用----如果处理程序尚未返回，内核不应再次调用它。”有两种方法

①可以在struct proc中新增一个字段，用于指示是否能够调用handler。当第一次调用handler时，将该字段置为1，表明不能再调用了。在sys_sigreturn之前将此字段清零即可。

②也可以直接根据ticks值进行判断。在test0的usertrap中，当ticks达到interval后我们将ticks置0了。现在将这句代码删除，而移至sys_sigreturn之后，即在最后函数返回前才会清零。因此，在handler还未结束时，ticks会继续递增，从而不会再满足调用handler的条件，自然就可以避免重入。

 

在sys_sigreturn中将trapframecopy拷贝到原trapframe中。恢复后将trapframecopy置零，表示当前没有副本。同时在拷贝trapframecopy前做了一个地址判断，是为了防止用户程序未调用sigalarm便使用了该系统调用。此时没有trapframecopy是无效的，可以避免错误拷贝。

拷贝不能p->trapframe=p->trapframecopy，因为后续要清0；所以要重新用一次把内存复制过去

memmove(p->trapframe, p->trapframecopy, sizeof(struct trapframe));

 