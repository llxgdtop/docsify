## 课前后内容

### C语言数据类型在RISC-V架构中的表现：

整数类型：int在RV32和RV64中都是32位宽。long和指针类型在RV32中是32位，在RV64中是64位。long long在两种架构中都是64位。

浮点类型：float是32位IEEE 754-2008浮点数，double是64位IEEE 754-2008浮点数，而long double是128位IEEE浮点数。

字符和短整型：char和unsigned char是8位无符号整数，signed char是8位有符号整数，short和unsigned short分别是16位有符号和无符号整数。这些类型在存储到RISC-V整数寄存器时有特定的扩展规则：

零扩展（Zero-Extension）

无符号类型：当char、unsigned char和unsigned short这些比整数寄存器小的无符号类型被加载到寄存器时，它们会进行零扩展。这意味着，原始数据的高位（在RISC-V整数寄存器中未被原始数据占用的部分）会被填充为0。例如，如果一个unsigned char值（8位）被存储到一个32位的整数寄存器中，那么它的高24位将被设置为0。

符号扩展（Sign-Extension）

有符号类型：对于signed char和short这些有符号类型，当它们被加载到寄存器时，会进行符号扩展。这意味着，原始数据的高位会被填充为原始数据的符号位（即最高有效位）的副本。

例如，如果一个signed char值（8位）被存储到一个32位的整数寄存器中，那么它的高24位将被设置为该signed char值的符号位（第7位）的副本。

32位类型在RV64中的扩展

RV64架构：在RV64架构中，32位的数据类型（如int）在被存储到64位的整数寄存器时，无论是有符号还是无符号类型，都会进行符号扩展。这意味着，对于32位的值，其高32位将被设置为原始32位值的最高位（符号位）的副本。

"高24位"指的是在一个更宽的数据类型中，除了最低的几位之外的所有位。例如，如果我们有一个8位的无符号整数（unsigned char）值0x12（在二进制中为0001 0010），并且我们将这个值存储到一个32位的整数寄存器中进行零扩展，那么这个值会被扩展为0x00000012。在这个32位的值中，最低的8位（0001 0010）是原始的unsigned char值，而剩下的24位（即从第8位到第31位，或者说是最高的24位）被填充为0，这些就是所谓的"高24位"。

以十六进制表示，这个过程可以看作：

原始值（8位）: 0x12

扩展后的值（32位）: 0x00000012

在这个例子中，0x000000就是被零扩展的"高24位"。

符号扩展是一种将较小的有符号数值扩展到较大位宽的方法，同时保持其原始的符号（正或负）不变。这是通过复制原始数值的最高位（符号位）到新扩展的位来实现的。这里用一个例子来解释符号扩展：

假设我们有一个8位的有符号整数（signed char）值0xFA。在二进制中，0xFA表示为1111 1010。注意，最高位（符号位）是1，表示这是一个负数。

现在，如果我们要将这个8位的值符号扩展到一个32位的整数寄存器中，我们会复制最高位（符号位）到所有新的高位中。因此，扩展后的32位值将是：

原始8位值：1111 1010（0xFA）

扩展到32位：1111 1111 1111 1111 1111 1111 1111 1010

在十六进制中，这个32位的值表示为0xFFFFFFFA。

通过这种方式，原始的负数值在扩展后仍然保持为负数，且其绝对值不变。这就是符号扩展的基本原理和操作方式。



### RISC-V调用约定：

参数传递：尽可能通过寄存器传递参数，最多使用8个整数寄存器（a0-a7）和8个浮点寄存器（fa0-fa7）。超出这些寄存器的参数通过栈传递。

返回值：函数返回值保存在整数寄存器a0和a1，以及浮点寄存器fa0和fa1中。更长的返回值通过内存返回，内存由调用者分配。

寄存器使用：除了参数和返回值寄存器外，还有临时寄存器（t0-t6和ft0-ft11）和保存寄存器（s0-s11和fs0-fs11），分别由调用者和被调用者负责保存。



### 软浮点数调用约定：

在没有浮点硬件支持的RV32和RV64机器上，浮点数参数通过整数寄存器传递和返回，遵循与整数参数相同的规则。动态舍入模式和异常标记通过C99的fenv.h头文件访问。

 

CPU（中央处理器）的组成可以分为几个核心部分，每个部分承担不同的功能：

算术逻辑单元（ALU）：负责执行所有的算术运算（如加、减、乘、除）和逻辑运算（如AND、OR、NOT）。

控制单元（CU）：解析程序指令，控制数据在CPU内部的流动，以及指挥其他部件按照指令执行操作。

寄存器：高速存储单元，用于暂存指令、数据和地址。包括程序计数器（PC）、指令寄存器（IR）、累加器（ACC）等。

缓存（Cache）：位于CPU内部或紧邻CPU的小容量但高速存储区域，用于临时存储频繁访问的数据和指令，以减少访问主存储器（RAM）的次数。

内部总线：连接CPU内部各个部件的通道，用于传输数据、指令和控制信号。

时钟（Clock）：控制CPU操作的时序，每个时钟周期CPU可以完成一定的操作。



## 课上内容

RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。这两者之间有一些关键的区别：

1.首先是指令的数量。实际上，创造RISC-V的一个非常大的初衷就是因为Intel手册中指令数量太多了。x86-64指令介绍由3个文档组成，并且新的指令以每个月3条的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有多于15000条指令。RISC-V指令介绍由两个文档组成。在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣或者你发现你不能理解某个具体的指令的话，在课程网站的参考页面有RISC-V指令的两个文档链接。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多的多。这是有关RISC-V比较好的一个方面。所以在RISC-V中，我们有更少的指令数量。

2.除此之外，RISC-V指令也更加简单。在x86-64中，很多指令都做了不止一件事情。这些指令中的每一条都执行了一系列复杂的操作并返回结果。但是RISC-V不会这样做，RISC-V的指令趋向于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员的在底层设计时的取舍。并没有一些非常确定的原因说RISC比CISC更好。它们各自有各自的使用场景。

![img](assets\clip_image002-1729266959027-1.jpg).section指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。.global表示你可以在其他文件中调用这个函数。text段保存代码，是只读和可执行的，每个进程的page table中有一个区域是text，汇编代码中的text表明这部分是代码，并且位于page table的text区域中。text中保存的就是代码。

![img](assets\clip_image004-1729266959028-2.jpg)在编译完之后，你可以查看kernel.asm文件，你可以看到XV6完整内核的汇编版本。文件中每一行左边的数字表明的是这条指令会在内存中的哪个位置。

寄存器之所以重要是因为汇编代码并不是在内存上执行，而是在寄存器上执行，也就是说，当我们在做add，sub时，我们是对寄存器进行操作。所以你们通常看到的汇编代码中的模式是，我们通过load将数据存放在寄存器中，这里的数据源可以是来自内存，也可以来自另一个寄存器。之后我们在寄存器上执行一些操作。如果我们对操作的结果关心的话，我们会将操作的结果store在某个地方。这里的目的地可能是内存中的某个地址，也可能是另一个寄存器。这就是通常使用寄存器的方法。

在谈到寄存器的时候，我们会用它们的ABI名字。不仅是因为这样描述更清晰和标准，同时也因为在写汇编代码的时候使用的也是ABI名字。

a0到a7寄存器是用来作为函数的参数。如果一个函数有超过8个参数，我们就需要用内存了。从这里也可以看出，当可以使用寄存器的时候，我们不会使用内存，我们只在不得不使用内存的场景才使用它。

Caller Saved寄存器在函数调用的时候不会保存

Callee Saved寄存器在函数调用的时候会保存

假设我们在函数a中调用函数b，任何被函数a使用的并且是Caller Saved寄存器，调用函数b可能重写这些寄存器。我认为一个比较好的例子就是Return address寄存器（注，保存的是函数返回的地址），你可以看到ra寄存器是Caller Saved，这一点很重要，它导致了当函数a调用函数b的时侯，b会重写Return address。所以基本上来说，任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。

所有寄存器都是64bit

![image-20241018235622077](assets\image-20241018235622077.png)

如果一个函数的返回值是long long型，也就是128bit，我们可以把它放到一对寄存器中。这也同样适用于函数的参数。所以，如果返回值超过了一个寄存器的长度，也就是64bit，我们可以将返回值保存在a0和a1。

 

每一个区域都是一个Stack Frame，每执行一次函数调用就会产生一个只给自己用的Stack Frame。函数通过移动Stack Pointer来完成Stack Frame的空间分配。对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。



一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样。不同的函数有不同数量的本地变量，不同的寄存器，所以Stack Frame的大小是不一样的。但是有关Stack Frame有两件事情是确定的：

1.Return address总是会出现在Stack Frame的第一位

2.指向前一个Stack Frame的指针也会出现在栈中的固定位置

有关Stack Frame中有两个重要的寄存器，第一个是SP（Stack Pointer），它指向Stack的底部并代表了当前Stack Frame的位置。第二个是FP（Frame Pointer），它指向当前Stack Frame的顶部。因为Return address和指向前一个Stack Frame的的指针都在当前Stack Frame的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。

Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。所以通常，在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epilogue。这就是一个汇编函数通常的样子。

![img](assets\clip_image002-1729267013918-5.jpg)

leaf函数是指不调用别的函数的函数，它的特别之处在于它不用担心保存自己的Return address或者任何其他的Caller Saved寄存器，因为它不会调用别的函数。

prologue：对Stack Pointer减16，这样我们为新的Stack Frame创建了16字节的空间。之后我们将Return address保存在Stack Pointer位置。![img](assets\clip_image002-1729267028794-7.jpg)

Epilogue：首先将Return address加载回ra寄存器，通过对Stack Pointer加16来删除刚刚创建的Stack Frame，最后ret从函数中退出。

![img](assets\clip_image004-1729267028794-8.jpg)

如果我们删除掉Prologue和Epilogue，然后只剩下函数主体，那么sum_then_double将不知道它应该返回的Return address。所以调用sum_to的时候，Return address被覆盖了，最终sum_to函数不能返回到它原本的调用位置。

输入i frame

![img](assets\clip_image006-1729267028794-9.jpg)

Stack level 0，表明这是调用栈的最底层

pc，当前的程序计数器

saved pc，demo4的位置，表明当前函数要返回的位置

source language c，表明这是C代码

Arglist at，表明参数的起始地址。当前的参数都在寄存器中，可以看到argc=3，argv是一个地址

如果输入backtrace（简写bt）可以看到从当前调用栈开始的所有Stack Frame。

可以认为struct像是一个数组，但是里面的不同字段的类型可以不一样。（比如int age和int id就是不同的字段）

![img](assets\clip_image008-1729267028795-10.jpg)

这里有一个名字是Person的struct，它有两个字段。我将这个struct作为参数传递给printPerson并打印相关的信息。我们在printPerson中设置一个断点，当程序运行到函数内部时打印当前的Stack Frame。

![img](assets\clip_image010.jpg)![img](assets\clip_image012.jpg)