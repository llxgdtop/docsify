## 课上内容

寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。

 

加载器将xv6内核加载到物理地址的内存中0x80000000。它将内核置于0x80000000而不是0x0是因为地址范围0x0～0x80000000包含I/O设备。

 

shell是用户和Linux（或者更准确的说，是用户和Linux内核）之间的接口程序。你在提示符下输入的每个命令都由shell先解释然后传给Linux内核。

 

一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。一个线程崩溃整个进程都死掉。

 

通常来说，如果没有操作系统，应用程序会直接与硬件交互

 

用user/kernel mode（也成为supervisor mode）以及page table或者虚拟内存vm virtual memory来实现应用程序和操作系统之间的强隔离性。

在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。

在RISC-V中，如果你在用户空间（user space）尝试执行一条特殊权限指令用户程序会通过系统调用来切换到kernel mode。当用户程序执行系统调用，会通过ECALL触发一个软中断（software interrupt），软中断会查询操作系统预先设定的中断向量表，并执行中断向量表中包含的中断处理程序。中断处理程序在内核中，这样就完成了user mode到kernel mode的切换，并执行用户程序想要执行的特殊权限指令。（user space：ecall to kernel space：syscall）

page table定义了对于内存的视图，而每一个用户进程都有自己对于内存的独立视图。这给了我们非常强的内存隔离性。（在page table里面都是0到2的x次方，但映射到物理内存后就不是了，所以两个程序/进程就不会互相干扰对方的内存）



![image-20241018233730049](assets\image-20241018233730049.png)

在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork还是什么别的系统调用，或者参数不正确不允许执行系统调用。用户不能直接调用fork，唯一方法就是通过ecall到syscall

补充：中断处理程序的上部分和下半部可以理解为：

1上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；一般说的中断即硬中断

2下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；

 

bios在操作系统之前启动，所以BIOS需要是一段可被信任的代码，它最好是正确的，且不是恶意的。

 

GDB 更常用来调试 C 和 C++ 程序。一般来说，GDB主要帮助我们完成以下四个方面的功能：

启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。

在某个指定的地方或条件下暂停程序。

当程序被停住时，可以检查此时你的程序中所发生的事。

在程序执行过程中修改程序中的变量或条件，将一个bug产生的影响修正从而测试其他bug。

 

可以多看几遍3.7，看一下一个操作系统是如何启动的。以xv6为例子，ls可以看到第一个是kernel（里面包含了基本上所有的内核文件），第二个是user，第三个是makefile。

1首先，Makefile（XV6目录下的文件）会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。之后为所有内核文件做相同操作，系统加载器（loader）收集所有.o，链接在一起生成内核文件（即会在qemu中运行的文件）

![image-20241018233748212](assets\image-20241018233748212.png)

2运行make qemu后显示东西的意思（即传给qemu的几个参数)

-kernel：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。

 

-m：这里传递的是RISC-V虚拟机将会使用的内存数量

 

-smp：这里传递的是虚拟机可以使用的CPU核数

 

-drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件

见3.9

 

 

QEMU仿真了RISC-V处理器时，背后的含义是什么？在内部，在QEMU的主循环中，只在做一件事情：1.读取4字节或者8字节的RISC-V指令。2.解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本（3.7）。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。之后，在软件中执行相应的指令。

 

这基本上就是QEMU的全部工作了，对于每个CPU核，QEMU都会运行这么一个循环。

 

userinit有点像是胶水代码/Glue code（胶水代码不实现具体的功能，只是为了适配不同的部分而存在），它利用了XV6的特性，并启动了第一个进程。我们总是需要有一个用户进程在运行，这样才能实现与操作系统的交互（能用syscall），所以这里需要一个小程序来初始化第一个用户进程。这个小程序定义在initcode中。

userinit调用initcode，userinit会创建初始进程，返回到用户空间，执行刚刚介绍的3条指令（initcode首先将init中的地址加载到a0（la a0, init），argv中的地址加载到a1（la a1, argv），exec系统调用对应的数字加载到a7（li a7, SYS_exec），最后调用ECALL），再回到内核空间，这里是任何用户使用到的第一个系统调用：查看syscall代码，num = p->trapframe->a7 会读取使用的系统调用对应的整数。当代码执行完这一行之后，我们可以在gdb中打印num，可以看到是7（对应exec系统调用）。

 

所以，这里本质是告诉内核，某个用户应用程序执行了ECALL指令，并且想要调用exec系统调用。

p->trapframe->a0 = syscall[num]() 这一行是实际执行系统调用。这里的num其实就是7。之后跳转到sys-exec函数，第一件事情是从用户空间读取参数，它会读取path，也就是要执行程序的文件名（打印path可见传入的就是init程序）。这里首先会为参数分配空间，然后从用户空间将参数拷贝到内核空间。

所以，综合来看，initcode完成了通过exec调用init程序。这个程序会为user space设置好一些东西，比如配置好console，调用fork，并在fork出的子进程中执行shell。此时就能看到shell运行起来了，可以运行命令了。

 

存根（stubs）是一种用于与操作系统交互的代码，它们在用户空间程序和内核之间充当桥梁，允许用户程序调用操作系统提供的功能。"存根"（stub）通常指的是一个简单的程序或函数，它的目的是在开发过程中替代或模拟某个功能或组件。存根的主要作用是提供一个占位符，使得程序的其余部分能够继续开发和测试，而不受到尚未实现的组件的影响。在user/usys.pl中，pl是perl脚本语言，它会打印一系列的汇编指令，将系统调用的名称和相应的系统调用编号关联起来，并定义每个系统调用的入口点，以便用户程序可以调用它们。

 

补充：grep hello README在文件名为README的文件中搜索包含字符串"hello"的行，并将匹配到的行显示出来

 

在第一个lab中

trace 32 grep hello README 用于跟踪 grep hello README 执行时系统调用 read 的执行情况（32=2的5次方，SYS_read = 5）trace 2147483647 grep hello README 用于跟踪 grep hello README 执行时所有系统调用的执行情况。按照它的要求The line should contain the process id, the name of the system call and the return value，包含了pid（在proc结构体中即proc.h，这个结构体的代表了一个进程的状态和属性。在操作系统中，进程是程序的一个执行实例，这个结构体包含了操作系统需要维护的关于每个进程的所有重要信息），系统调用名（这个根据syscall_names[num]即可知道），以及系统调用的返回值（返回值存在a0寄存器中）

 

所以，增加系统调用的流程：浏览器收藏也有（那个是内核态），这个是lab（给出的代码是用户态）的流程

1在makefile中添加对应的东西

2 将要添加的系统调用名trace添加到user.h中，看一下系统调用返回值是什么（用户态），看看传进去的参数是什么类型的，这一点要注意，否则编译不出来，以这个lab为例子，返回值是int，传入是一个int类型的mask（掩码，实验要求中用argument表示，翻译为实参，Parameter翻译为形参，不过一般都翻译为参数），之后在usys.pl中添加桩代码entry(“trace”)

3 在syscall.h中添加系统调用的宏定义

4 在进程结构体中添加成员变量mask（因为题目要求要跟踪系统调用嘛，而且每个进程的信息都存在了proc结构体里面，故自然而然在这个结构体里面加），表示当前进程需要跟踪的系统调用

  4.1见usys.s，一个类似与switch语句的汇编代码，使用系统调用的时候，会查询对应的标签来执行相应的代码，把sys-xxx这个名字放入寄存器a7，之后ecall提升硬件权限进入内核，之后执行syscall函数

  4.2查看syscall函数代码，num = p->trapframe->a7;从寄存器a7中读取系统调用号。接下来p->trapframe->a0 = syscalls[num]();通过调用syscalls[num]();函数把返回值保存在了a0寄存器中。

5由于使用了syscalls[num]();，故要在这个函数内添加[SYS_trace]  sys_trace,（把trace改掉就行了，别忘记逗号）以及extern uint64 sys_trace(void);以及在syscall-names[]里面添加一项；

6在sysproc.c中添加内核态系统调用（总的来说，就用户态使用伪系统调用，通过ecall进入内核，内核再调用真正的系统调用）,在这个.c文件中是操作系统内核中系统调用的实现部分，可以说是内核态和用户态的交流过程。如果利用了别的函数，以sys-fork为例，它return fork（）,而fork在proc.c中实现，那么就得在defs.h中声明一下这个函数，trace没有因为没有利用别的函数就不用声明

7 对于此lab而言，添加子进程复制父进程的mask（在fork中），之后修改syscall函数打印

别人总结的流程：https://horbyn.github.io/2022/03/16/xv6-2/#/INTRO-v2 。

 

struct students stu[NUM]={{"Allen",18},{"Smith",19},{"Grace",18}};//定义结构体数组并初始化

 

copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)，成功返回0，失败返回-1；该函数其实就是把在内核地址 src 开始的 len 大小的数据拷贝到用户进程 pagetable 的虚地址 dstva 处

![image-20241018233828831](assets\image-20241018233828831.png)

CPU虚拟化提供每个用户程序独占机器运行的假象，内存虚拟化则提供每个用户程序独占计算机内存的假象。对于内存虚拟化，我们来看看进程是如何设计的。xv6引入了页表，这些页表由硬件实现，使用页表是一个很通用的解决方案。高地址是靠近0的。可以看到

![image-20241018233841411](assets\image-20241018233841411.png)

虚拟地址从0开始，一直增长到最大MAXVA。用户程序在其中的布局，首先是用户程序的指令和全局变量，然后是栈，接着是堆（一般习惯将堆安排在低地址，而栈安排在高地址），最后在虚拟地址空间的顶端保留了两页，一页装载的是trampoline，另一页装载的是trapframe（这两页共同完成切换到内核的工作，在后面的章节中还会再详细介绍它们）。

 

其中，syscall.c、syscall.h两个文件定义了该系统调用标识SYS_cps和系统调用函数sys_cps，proc.c中的cps实现了该函数的具体功能，user.h和defs.h则具体定义了功能函数cps，usys.S则实现了用户访问系统调用的接口，而最后的sysproc.c是将用户和系统调用相连的关键部分。
