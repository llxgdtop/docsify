## 课前内容

通过在CPU上不断切换执⾏不同的进程，就能够满⾜我们时分复⽤CPU的⽬标，在xv6中，这种切换

可以在以下情况发⽣：

​     sleep和wakeup机制。当⼀个进程在等待某种资源可⽤或某种条件成⽴，如设备、管道、或⼦进程的退出时，进程可以通过sleep主动放弃CPU，让其它的进程执⾏，然后稍后条件满⾜时，再通过wakeup唤醒该进程重新执⾏，这就实现了⼀种切换执⾏进程的⽅式。

​     轮转调度Round-Robin机制。每⼀个进程都有⼀个时间⽚，时间⽚耗尽时，时钟中断也随之发⽣当前执⾏进程就会被挂起，⽽新的进程会被调度执⾏。只要中断没有被关闭，这种调度就能强制执⾏，因此xv6能够公平地，轮转地调度不同的进程在CPU上执⾏。

 

最简单的，要从⼀个进程切换到另⼀个进程，我们应该要保存旧进程的相关运⾏状态和寄存器（上下

⽂Context），然后通过某种⽅式选择⼀个将要执⾏的进程，恢复这个进程上次的运⾏状态，然后继续

执⾏它，这样我们就完成了整个调度过程。

事实上，xv6的进程调度⽅式也遵循以上的基本思想，当然也有部分不同，例如：

​    xv6中，每个进程都有⼀个⽤户空间下的执⾏线程，当该进程因trap陷⼊内核空间下执⾏后，我

们就称它为内核线程。xv6的进程调度实际上是针对内核线程的。

​    在调度的时候，我们并不是直接地从⼀个进程的内核线程跳转到另⼀个内核线程，在这中间还

有⼀个第三者⸺CPU的调度线程scheduler，每个CPU都有⼀个调度线程，在没有任何⽤户进

程可运⾏时，这些CPU就运⾏各⾃的调度线程，很快我们将看到它的作⽤。

​     和⽤户态的上下⽂（trapframe所包含的）不同，内核态的上下⽂只是它的⼀个⼦集。

 

以时钟中断引发的进程调度为例，原⽤户进程通过trap陷⼊内核空间，原内核线程进⾏上下⽂切换，

回到该CPU的调度线程中，调度线程决定新的要运⾏的⽤户进程，因⽽⼜进⾏⼀次上下⽂切换，切换

到新内核线程中，最后，再从新内核线程返回到⽤户空间，新⽤户进程得以执⾏。

![img](assets\clip_image002-1729268089040-1.jpg)上下⽂切换的核⼼函数是swtch(a0, a1)（kernel/swtch.S），如下所示，做的事情很简单，就是保存

a0的内核态上下⽂，恢复a1的内核态上下⽂。所以上图中的两次上下⽂切换，可以简单表示为

swtch(old_thread->context, scheduler_thread->context)和swtch(scheduler_thread->context,

new_thread->context)。内核线程的上下⽂保存在进程的结构p->context中，⽽CPU的调度线程上

下⽂则保存⾄cpu->context中。这个context只是trapframe的⼀个⼦集。context只包含Calleesaved registers，⾄于Caller-saved registers，则不由被调⽤者swtch负责保存和恢复，如果确实需

要维持这些值，以防⽌被调⽤者覆盖它们，则由调⽤者⾃⼰保存在它的内核栈上。

 

需要理解的是，swtch并不会返回到同⼀个内核线程中，因为我们恢复的是另⼀个内核线程的ra，所

以swtch会返回到另⼀个内核线程中。为了便于你理解，你可以形象化地把swtch想象成是⼀个传送

⻔，从⼀个地⽅"传送"到另⼀个地⽅，但实际上，这是有迹可循的。所以你通过⼀个swtch离开了当

前的线程，下⼀次⼀定是通过别的swtch回到该线程中。

 

 

**⽤户进程** **PA->usertrap->内核线程TA->yield(TA)->sched(TA)->swtch(TA, S)->调度线程S->swtch(S, TB)->sched(TB)->yield(TB)->内核线程TB->usertrapret->⽤户进程PB**

**记住！！！**

![img](assets\clip_image004-1729268089040-2.jpg)

 

 

yield（kernel/proc.c）所做的事情很简单，该内核线程准备要让出CPU，因此⾸先要获取该进程的锁

p->lock，因为我们要修改p->state，⽽且应该⼀直持有p->lock，直到进⼊调度器中。（为什么从调

⽤yield开始，持有p->lock直到在scheduler中释放；或者是从scheduler开始，持有p->lock直到在

yield的出⼝处释放。因为p->lock保证了取消调度和调度这两个过程的原⼦执⾏：

​     如果进程状态是RUNNING，那么时钟中断导致的yield可以安全地，从这个进程的内核线程，

切换到调度线程的调度器中。在这个过程中，CPU寄存器要保持着该进程的寄存器值，c->proc要保持指向该进程。

​     如果进程状态是RUNNABLE，那么调度器可以安全地，调度执⾏这个进程。在这个过程中，p-

\>context要保持着该进程的寄存器值，没有CPU使⽤该进程的内核栈，⽽且没有CPU的c-

\>proc指向该进程。

）

 

 

sched做的事情要多⼀些。⾸先，再次检查是否持有p->lock；然后，检查是否持有其它的锁（通过检

查cpu的noff，也就是中断嵌套的层数，检测出是否除了p->lock以外还有其它的锁，因为acquire会

关闭中断，⽽且可以叠加），持有其它的锁然后放弃CPU是不允许的，即我们不能在调⽤swtch之

前，持有除了p->lock以外的其它锁，这⼀点我们也留到以后解释；接着再完成进程状态和中断的检

查。（这个问题的原因是可能会导致死锁。如果在单CPU上，⼀个内核线程持有了除p->lock以外的

其它锁m，然后swtch到调度器，调度器再swtch执⾏⼀个新的内核线程，假如新的内核线程也要获

取锁m的话，那么死锁就发⽣了，因为acquire关闭中断，所以整个流程都会卡住。）

 

 

每个CPU都有⼀个调度线程，它运⾏我们的调度器scheduler。调度器负责取消调度旧的内核线程，

决定下⼀个要运⾏的内核线程，然后swtch到新的内核线程，开始执⾏它。

 

可以看到，sched和scheduler表现为⼀对协同程序，⼀个内核线程的sched通过swtch切换到

scheduler中，⽽scheduler⼜通过swtch切换回到另⼀个内核线程的sched中。但是，这种协同并不

是绝对的，有⼀个例外，就是进程刚被创建的时候。

 

xv6将每个CPU的hartid存储在相应CPU的thread pointer，即tp寄存器中。

 

因为时钟中断随时可能发⽣，为了保证mycpu或者说cpuid返回的值是正确的，在调⽤mycpu并且使

⽤该cpu值的时候，应该保持中断的关闭。



## 课上内容

线程的状态包含了三个部分：

程序计数器（Program Counter），它表示当前线程执行指令的位置。

保存变量的寄存器。

程序的Stack（注，详见5.5）。通常来说每个线程都有属于自己的Stack，Stack记录了函数调用的记录，并反映了当前线程的执行点。

 

不同线程系统之间的一个主要的区别就是，线程之间是否会共享内存。一种可能是你有一个地址空间，多个线程都在这一个地址空间内运行，并且它们可以看到彼此的更新。比如说共享一个地址空间的线程修改了一个变量，共享地址空间的另一个线程可以看到变量的修改。所以当多个线程运行在一个共享地址空间时，我们需要用到上节课讲到的锁。

XV6内核共享了内存，并且XV6支持内核线程的概念，对于每个用户进程都有一个内核线程来执行来自用户进程的系统调用。所有的内核线程都共享了内核内存，所以XV6的内核线程的确会共享内存。

另一方面，XV6还有另外一种线程。每一个用户进程都有独立的内存地址空间（注，详见4.2），并且包含了一个线程，这个线程控制了用户进程代码指令的执行。所以XV6中的用户线程之间没有共享内存，你可以有多个用户进程，但是每个用户进程都是拥有一个线程的独立地址空间。XV6中的进程不会共享内存。

简单来说，内核线程会共享内存，用户线程不会。（xv6系统，linux会共享）

 

停止一个线程的运行并启动另一个线程的过程通常被称为线程调度（Scheduling）。我们将会看到XV6为每个CPU核都创建了一个线程调度器（Scheduler）。

pre-emptive scheduling。pre-emptive的意思是，即使用户代码本身没有出让CPU，定时器中断仍然会将CPU的控制权拿走，并出让给线程调度器。与之相反的是voluntary scheduling。在XV6和其他的操作系统中，线程调度是这么实现的：定时器中断会强制的将CPU控制权从用户进程给到内核，这里是pre-emptive scheduling，之后内核会代表用户进程（注，实际是内核中用户进程对应的内核线程会代表用户进程出让CPU），使用voluntary scheduling。

 

在执行线程调度的时候，操作系统需要能区分几类线程：

当前在CPU上运行的线程

一旦CPU有空闲时间就想要运行在CPU上的线程

以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件

 

当用户程序在运行时，实际上是用户进程中的一个用户线程在运行。如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的用户空间状态会被保存在程序的trapframe中（注，详见lec06），同时属于这个用户程序的内核线程被激活。所以首先，用户的程序计数器，寄存器等等被保存到了trapframe中，之后CPU被切换到内核栈上运行，实际上会走到trampoline和usertrap代码中（注，详见lec06）。之后内核会运行一段时间处理系统调用或者执行中断处理程序。在处理完成之后，如果需要返回到用户空间，trapframe中保存的用户进程状态会被恢复。

除了系统调用，用户进程也有可能是因为CPU需要响应类似于定时器中断走到了内核空间。上面提到的pre-emptive scheduling，会通过定时器中断将CPU运行切换到另一个用户进程。在定时器中断程序中，如果XV6内核决定从一个用户进程切换到另一个用户进程，那么首先在内核中第一个进程的内核线程会被切换到第二个进程的内核线程。之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回也是通过恢复trapframe中保存的用户进程状态完成。

 

简单来说，现在有两个程序CC and ls

1XV6会首先会将CC程序的内核线程的内核寄存器保存在一个context对象中。

2类似的，因为要切换到LS程序的内核线程，那么LS程序现在的状态必然是RUNABLE，表明LS程序之前运行了一半。这同时也意味着LS程序的用户空间状态已经保存在了对应的trapframe中，更重要的是，LS程序的内核线程对应的内核寄存器也已经保存在对应的context对象中。所以接下来，XV6会恢复LS程序的内核线程的context对象，也就是恢复内核线程的寄存器。

3之后LS会继续在它的内核线程栈上，完成它的中断处理程序（注，假设之前LS程序也是通过定时器中断触发的pre-emptive scheduling进入的内核）。

4然后通过恢复LS程序的trapframe中的用户进程状态，返回到用户空间的LS程序中。

5最后恢复执行LS。

![img](assets\clip_image002-1729268154088-5.jpg)

 假设在XV6中我们有2个CPU核，这意味着在硬件层面我们有CPU0和CPU1。

我们从一个正在运行的用户空间进程切换到另一个RUNABLE但是还没有运行的用户空间进程的更完整的故事是：

 

1 首先与我之前介绍的一样，一个定时器中断强迫CPU从用户空间进程切换到内核，trampoline代码将用户寄存器保存于用户进程对应的trapframe对象中；

2 之后在内核中运行usertrap，来实际执行相应的中断处理程序。这时，CPU正在进程P1的内核线程和内核栈上，执行内核中普通的C代码；

3假设进程P1对应的内核线程决定它想出让CPU，它会做很多工作，这个我们稍后会看，但是最后它会调用swtch函数（译注：switch 是C 语言关键字，因此这个函数命名为swtch 来避免冲突），这是整个线程切换的核心函数之一；

4 swtch函数会保存用户进程P1对应内核线程的寄存器至context对象。所以目前为止有两类寄存器：用户寄存器存在trapframe中，内核线程的寄存器存在context中。

 

但是，实际上swtch函数并不是直接从一个内核线程切换到另一个内核线程。XV6中，**一个****CPU****上运行的内核线程可以直接切换到的是这个CPU****对应的调度器线程。**所以如果我们运行在CPU0，swtch函数会恢复之前为CPU0的调度器线程保存的寄存器(存在context结构体中）和stack pointer，之后就在调度器线程的context下执行schedulder函数中（注，后面代码分析有介绍）。

 

在schedulder函数中会做一些清理工作，例如将进程P1设置成RUNABLE状态。之后再通过进程表单找到下一个RUNABLE进程。假设找到的下一个进程是P2（虽然也有可能找到的还是P1），schedulder函数会再次调用swtch函数，完成下面步骤：

1 先保存自己的寄存器到调度器线程的context对象

2 找到进程P2之前保存的context，恢复其中的寄存器

3 因为进程P2在进入RUNABLE状态之前，如刚刚介绍的进程P1一样，必然也调用了swtch函数。所以之前的swtch函数会被恢复，并返回到进程P2所在的系统调用或者中断处理程序中（注，因为P2进程之前调用swtch函数必然在系统调用或者中断处理程序中）。

5 不论是系统调用也好中断处理程序也好，在从用户空间进入到内核空间时会保存用户寄存器到trapframe对象。所以当内核程序执行完成之后，trapframe中的用户寄存器会被恢复。

最后用户进程P2就恢复运行了。

 

学生提问：context保存在哪？

Robert教授：每一个内核线程都有一个context对象。但是内核线程实际上有两类。每一个用户进程有一个对应的内核线程，它的context对象保存在用户进程对应的proc结构体中。

每一个调度器线程，它也有自己的context对象，但是它却没有对应的进程和proc结构体，所以调度器线程的context对象保存在cpu结构体中。在内核中，有一个cpu结构体的数组，每个cpu结构体对应一个CPU核，每个结构体中都有一个context字段。

 

学生提问：每一个CPU的调度器线程有自己的栈吗？

Robert教授：是的，每一个调度器线程都有自己独立的栈。实际上调度器线程的所有内容，包括栈和context，与用户进程不一样，都是在系统启动时就设置好了。如果你查看XV6的entry.S和start.c文件，你就可以看到为每个CPU核设置好调度器线程。

 

**每一个CPU**核在一个时间只会做一件事情，每个CPU核在一个时间只会运行一个线程，它要么是运行用户进程的线程，要么是运行内核线程，要么是运行这个CPU核对应的调度器线程。所以在任何一个时间点，CPU核并没有做多件事情，而是只做一件事情。线程的切换创造了多个线程同时运行在一个CPU上的假象。类似的每一个线程要么是只运行在一个CPU核上，要么它的状态被保存在context中。线程永远不会运行在多个CPU核上，线程要么运行在一个CPU核上，要么就没有运行。****

**每个进程有两个线程，一个用户空间线程，一个内核空间线程，并且存在限制使得一个进程要么运行在用户空间线程，要么为了执行系统调用或者响应中断而运行在内核空间线程** **，但是永远也不会两者同时运行。**

 

具体过程见 https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec11-thread-switching-robert/11.5-xv6-thread-switching-code ；以下是其中一些部分

 

Struct cpu* c=mycpu(); struct proc *p=myproc();

swtch(&p->context,&c->context);swtch函数会将当前的内核线程的寄存器保存到p->context中。swtch函数的另一个参数c->context，c表示当前CPU的结构体。CPU结构体中的context保存了当前CPU核的调度器线程的寄存器。所以swtch函数在保存完当前内核线程的内核寄存器之后，就会恢复当前CPU核的调度器线程的寄存器，并继续执行当前CPU核的调度器线程。

swtch函数中有两个参数a0和a1，a0寄存器对应了swtch函数的第一个参数，从前面可以看出这是当前线程的context对象地址 ；a1寄存器对应了swtch函数的第二个参数，从前面可以看出这是即将要切换到的调度器线程的context对象地址。

所以函数中上半部分是将当前的寄存器保存在当前线程对应的context对象中，函数的下半部分是将调度器线程的寄存器，也就是我们将要切换到的线程的寄存器恢复到CPU的寄存器中。之后函数就返回了。所以调度器线程的ra寄存器的内容才显得有趣，因为它指向的是swtch函数返回的地址，也就是scheduler函数。

 

**在XV6**中，一个进程只有一个用户线程,但linux中一个进程有多个线程。或许最简单的解释方式是：几乎可以认为Linux中的每个线程都是一个完整的进程。Linux中，我们平常说一个进程中的多个线程，本质上是共享同一块内存的多个独立进程。所以Linux中一个进程的多个线程仍然是通过一个内存地址空间执行代码。如果你在一个进程创建了2个线程，那基本上是2个进程共享一个地址空间。之后，调度就与XV6是一致的，也就是针对每个进程进行调度。****

 

## lab内容

![img](assets\clip_image002-1729268241665-7.jpg)

1从 CC 用户线程陷入 CC 内核线程（CCk），陷入过程中在 trampoline() 内将用户线程上下文保存到 trapframe

2 CCk 要让出 CPU，进入 swtch() 上半场的处理。先保护 CCk 现场，存入 context 对象（**context** **结构体总是保存了内核线程在执行 swtch()** **时的状态；而 trapframe** **栈帧总是保存了用户线程在执行 trampoline()** **时的状态）**

3 swtch() 恢复当前 CPU 调度器的上下文和栈，之后用这个环境执行 scheduler()

4 scheduler() 先将 CCk 状态改为 RUNNABLE，然后在进程表中找到 LSk，最后又调用 swtch()（只不过此时的 swtch() 不是刚才进入的那个）

5 进入 swtch() 下半场：

 5.1先将调度器的上下文和栈保存到自己的 context 对象

 5.2 再将 LSk 的 context 对象恢复，即加载为当前 CPU 寄存器组，从而恢复上次被打断的 swtch()

6 返回到 LSk 的 trampoline，恢复 trapframe

7 恢复 LS 用户线程

 

值得注意的是，这里的两个 swtch() 调用实际不是同一个。进入调度器的是 sched() 的 swtch()；而调度器返回的却是 scheduler() 的 swtch()。上述例子对应的程序流如下：

陷入：trampoline() -> usertrap() -> devintr()

让出 CPU：-> yield() -> sched()

保护现场并切换至调度器：-> swtch()

调度器进行调度：-> scheduler()

另一个线程登场：-> swtch()

 

xv6 总共包含三种类型的上下文信息：

用户上下文：由 trapframe 结构体保存

内核上下文：由 context 结构体保存

调度器上下文：由 cpu 结构体保存（cpu 结构体包含 context 成员，所以最终也是保存在 context 对象上。只不过区分不同的调度器线程是依据 cpu 是否相同，只有 cpu 寄存器环境才标识一个调度器）



### Uthread: switching between threads

这个lab的流程和内核线程切换差不多，线程要在它自己的堆栈上运行代码，所以在threadcreate中要把堆栈数组最后一个元素的指针放入保存堆栈顶指针的sp寄存器。

 

堆栈初始化：每个线程都应当有自己独立的堆栈，线程运行时通过寄存器sp来读写堆栈。寄存器sp保存指向堆栈顶部的指针，但线程的堆栈增长方向是从下向上增长的（即从大内存编号向低内存编号增长），因此sp中的指针应当指向struct thread中**堆栈数组的最后一个元素（即栈顶）**。

什么意思？

 

独立的堆栈：

每个线程都有自己的堆栈。堆栈是一种数据结构，用于存储局部变量、函数参数、返回地址等。在多线程环境中，每个线程拥有独立的堆栈确保它们的执行环境不会互相干扰。

寄存器sp（Stack Pointer）：

堆栈指针（sp）是一个寄存器，用于跟踪当前堆栈顶的位置。在函数调用和返回时，此寄存器的值会被更新，以指向堆栈上正确的位置。

堆栈增长方向：

**线程的堆栈增长方向是从下向上增长的。在大多数现代计算机架构中，这意味着堆栈从内存中的高地址向低地址增长。即，随着数据被推入堆栈，堆栈指针（sp****）的值逐渐减小。**

sp指向堆栈顶：

在描述中提到，sp应当指向堆栈数组的最后一个元素。这是因为“最后一个元素”在内存中的地址是最低的，适合作为堆栈的起始点（顶部），符合“从高地址向低地址增长”的堆栈增长规则。当你在堆栈上推入新的数据时，数据存放的位置先于（即在内存地址上小于）当前sp指向的位置。**即越高的内存地址那么对应所在的栈的位置就越靠近底部。**

实际应用

例如，在C语言中，如果定义了一个如下的线程结构体：

\#define STACK_SIZE 1024 // 假设堆栈大小为1024个字节

struct thread {

  char stack[STACK_SIZE]; // 堆栈空间

  // 其他线程相关的状态信息

};

初始化一个线程的堆栈指针时，我们会这样设置：

struct thread myThread;

myThread.sp = &myThread.stack[STACK_SIZE - 1];

这里，**myThread.sp** **被初始化为指向 myThread.stack** **数组的最后一个元素的地址**，从而作为堆栈的起始点。当后续有元素需要推进堆栈时，操作通常涉及几个步骤，主要是更新堆栈指针（sp）并在堆栈上存放数据。这里，我会详细说明这一过程，包括如何在一般的情况下操作堆栈。

\### 堆栈操作的基本概念

1. **推入元素（Push）**：

  \- 当一个元素被推入堆栈时，堆栈指针首先向下移动（即向内存地址较低的方向），然后将元素存放在堆栈指针指向的新位置。

2. **弹出元素（Pop）**：

  \- 当从堆栈中移除（弹出）一个元素时，元素首先从堆栈指针指向的位置被读取，然后堆栈指针向上移动（即向内存地址较高的方向）。

\### 示例：堆栈操作过程（推入int类型数据）

void push(struct thread *t, int value) {

  t->sp--;        // 将堆栈指针向下移动，准备空间

  *(int *)(t->sp) = value; // 在堆栈指针当前指向的位置存放值

}

这里，我们首先将 `sp` 减少，因为 `int` 类型通常占用 4 字节（这取决于系统和编译器），但因为 `sp` 是按字节管理的，所以直接减1就已足够演示（在实际中可能需要按 `sizeof(int)` 调整）。然后，我们将需要推入的值存放在 `sp` 现在指向的位置。

如果要弹出一个元素，操作如下：

int pop(struct thread *t) {

  int value = *(int *)(t->sp); // 从堆栈指针当前指向的位置读取值

  t->sp++;           // 将堆栈指针向上移动，回收空间

  return value;

}

\### 注意事项

\- **对齐**：在实际中，通常需要确保数据类型对齐，这意味着数据应当存储在其大小的整数倍的地址上。例如，如果是 `int` 类型（通常是 4 字节），那么其地址应该是 4 的倍数。

\- **安全性**：在实际应用中，还需要考虑堆栈溢出和下溢的安全问题，确保堆栈的使用不会超出分配的范围。

\- **系统依赖**：上述操作和大小可能依赖于具体的系统架构和编译器，因此在实际应用中需要根据目标平台调整细节。

通过这样的操作，可以实现数据在堆栈中的推入和弹出，支撑了函数调用、局部变量存储等关键功能。

 

### Using threads

本lab不能为哈希表添加course-grain lock，要为每一个桶都添加一把锁，在已给出的代码中，已经创建了5个桶，若不给每个桶加锁，每个线程会互相干扰不同的桶导致key missing。分桶的锁可以使不同的桶的存取操作依然保持并发，而一把锁则使得所有的存取操作都必须非并发。

在哈希表中，每个键都对应着一个值，形成一个键值对。桶则用于存储一个或多个这样的键值对(key可以不同）。下面是哈希表的更准确的描述：

哈希表结构

键（Key）：是哈希表中用于标识特定数据项的唯一标识符。在哈希表的上下文中，每个键都是唯一的。

值（Value）：与键相关联的数据。每个键都有一个相应的值，这构成了一个“键值对”。

桶（Bucket）：哈希表中的一个存储位置，每个桶可以存储一个或多个键值对。这里的“一个或多个”取决于哈希表中键的分布和碰撞解决机制。



### Barrier

每个round中，检测bstate.nthread的数量是否等于传入的命令行参数nthread，若小于则睡眠，等于则bstate.thread清零，然后轮次增加（这两个都是为了下一个round做初始化），唤醒这个round中所有等待的线程。

thread(void *xa): 线程执行的函数，模拟了一种持续的工作，其中包括：

检查自身的迭代次数是否与屏障轮次相等（确保同步）。

调用 barrier() 确保所有线程同步。

随机延时，模拟实际工作。