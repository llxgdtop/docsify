## 课前内容

⼀个进程可以调⽤sleep，从⽽等待⼀个事件的发⽣；当事件确实发⽣之后，另⼀个进程调⽤wakeup

唤醒该等待进程。这种协同⼯作的⽅式，我们称为条件同步Conditional Synchronization。基本的思

想是，sleep将调⽤进程的运⾏状态标记为SLEEPING，然后调⽤sched让出CPU，后续的调度过程前

⾯已经讨论过；wakeup则查找⼀个睡眠/等待在给定频道channel上的进程，然后将其状态设为

RUNNABLE。这个channel可以很随意地设置，xv6则经常使⽤⼀些内核数据结构的地址来作为

channel，以将所有与该数据结构相关的进程，都关联到同⼀个channel上。(channel理解为进程在等待channel这个事件）

 

每个管道都由⼀个struct pipe（kernel/pipe.c）代表，包含了⼀把⾃旋锁，⼀个缓冲区data，对管道

读写的字节数计数值，以及表示读写端打开的标志位。缓冲区是循环的，即data[PIPESIZE-1]的下⼀

个是data[0]，但是计数值不循环。从⽽我们可以区分，nwrite==nread+PIPESIZE时，缓冲区满；

nwrite==nread时，缓冲区空。但因此，在索引缓冲区时，我们也需要⽤取模操作，如

data[nread%PIPESIZE]。

 

假设不同的CPU并发地调⽤这两个函数。⾸先，pipewrite获取管道的锁pi->lock；piperead紧随其

后，但是阻塞在⼊⼝处，等待锁被释放。pipewrite在循环中写⼊字节，直到缓冲区满了，然后调⽤

wakeup，告知所有睡眠的piperead进程，现在缓冲区⾥有数据可读，然后⾃⼰调⽤sleep，释放pi-

\>lock，等待piperead进程读出⼀些数据。

 

因为pi->lock现在可⽤，所以piperead现在获得pi->lock并进⼊临界区，检查缓冲区有数据可读，于

是在循环中读出缓冲区⾥的数据，全部读出之后，调⽤wakeup，告知所有睡眠的pipewrite进程，现

在缓冲区有空闲空间可以写⼊数据，然后⾃⼰释放pi->lock并退出。

再次提醒，使⽤⼀个循环检查进程被唤醒时条件是否满⾜是很重要的。

 

xv6为了让⽗进程的wait发现⼦进程已经终⽌，在⼦进程exit的时候，将其运⾏状态设置ZOMBIE，然后wait就会注意到这个终⽌的⼦进程，并将该⼦进程标记为UNUSED，复制⼦进程的退出状态，并且返回⼦进程PID给⽗进程。如果⽗进程⽐⼦进程先exit，那么它的⼦进程都会托管给init进程（第⼀个⽤户进程，第⼆个是shell），即init进程现在是它们的⽗进程，init进程（user/init.c）就是在循环中不断地调⽤wait，如下所示，以释放这些被托管给它的终⽌⼦进程的资源。因此，每个⼦进程终⽌并退出后，都由它的⽗进程清理释放它们。在实现这两个接⼝的时候，要注意wait和exit，⼜或是exit和exit之间可能会出现竞争条件或死锁。

 

wait使⽤调⽤进程的p->lock作为条件锁，以防⽌唤醒丢失。wait在开始时先获取调⽤进程的p-\>lock，然后在⼀个循环中扫描所有进程，如果发现是它的⼦进程，就获取⼦进程的锁np->lock，并检

查⼦进程状态，如果状态是ZOMBIE，那么就将⼦进程的退出状态复制到wait传⼊的地址addr，并调

⽤freeproc清理⼦进程的资源和进程结构，最后释放np->lock和p->lock，并且返回退出⼦进程的

pid。如果wait发现⾃⼰没有⼦进程，就会直接返回；如果它的⼦进程都没有终⽌，那么wait接下来就

会调⽤sleep挂起⾃⼰，释放调⽤进程的锁p->lock，等待它的其中⼀个⼦进程调⽤exit终⽌。注意到

wait在⼀段时间内同时持有两把锁，⽽xv6规定的顺序是，先对⽗进程上锁，再对⼦进程上锁，以防

⽌死锁发⽣。

 

exit是让调⽤进程终⽌⾃⼰，⽽kill则能够让调⽤进程终⽌别的进程。如果让kill直接终⽌指定的进程，

可能会让代码变得复杂，因为那个进程可能正在被其它CPU执⾏，可能正处于临界区中，更新某些重要数据结构。显然我们需要⼀种更合理的kill⽅式。所以kill做的事情很有限，它将⽬标进程的p->killed设为1，同时如果⽬标进程正在睡眠，将其状态设为RUNNABLE，从⽽将其唤醒。最终，要被终⽌的进程总有机会进⼊或离开内核空间，如下所示，然后在usertrap中的两个检查点，检查p->killed是否为真：系统调⽤发⽣之前；或者trap处理完成，进⼊usertrapret之前。如果进程p->killed为真，就调⽤exit终⽌该进程。

 

为什么在sleep函数中要传入一个条件锁？

​    简单来说，是防止lost wakeup。

​    条件锁 lk：用于保护共享资源或条件（chan）的访问（去除 lk 可能导致这些资源在没有足够保护的情况下被访问，从而引起数据不一致或竞态条件）。在 sleep 函数中通过先释放 lk 并获取状态锁 p->lock 的方式，确保在 wakeup 函数中尝试获取状态锁时不会发生死锁。

​    状态锁 p->lock：负责保护进程状态（如 SLEEPING、RUNNABLE）的访问与修改。

​    如果没有条件锁，那么在p.state==sleeping之前可能会发生一个wakeup，之后再发生sleeping，那么这个进程就会lost wakeup。

 

## 课上内容

前面内容回顾：

实际上的代码顺序更像这样：

1一个进程出于某种原因想要进入休眠状态，比如说出让CPU或者等待数据，它会先获取自己的锁；

2之后进程将自己的状态从RUNNING设置为RUNNABLE；

3之后进程调用switch函数，其实是调用sched函数在sched函数中再调用的switch函数；

4switch函数将当前的线程切换到调度器线程；

5调度器线程之前也调用了switch函数，现在恢复执行会从自己的switch函数返回；

6返回之后，调度器线程会释放刚刚出让了CPU的进程的锁

在第1步中获取进程的锁的原因是，这样可以阻止其他CPU核的调度器线程在当前进程完成切换前，发现进程是RUNNABLE的状态并尝试运行它。为什么要阻止呢？因为其他每一个CPU核都有一个调度器线程在遍历进程表单，如果没有在进程切换的最开始就获取进程的锁的话，其他CPU核就有可能在当前进程还在运行时，认为该进程是RUNNABLE并运行它。而两个CPU核使用同一个栈运行同一个线程会使得系统立即崩溃。所以，在进程切换的最开始，进程先获取自己的锁，并且直到调用switch函数时也不释放锁。而另一个线程，也就是调度器线程会在进程的线程完全停止使用自己的栈之后，再释放进程的锁。释放锁之后，就可以由其他的CPU核再来运行进程的线程，因为这些线程现在已经不在运行了。

 

XV6中，不允许进程在执行switch函数的过程中，持有任何其他的锁（也就是p->lock以外的其他锁）。所以，进程在调用switch函数的过程中，必须要持有p->lock（注，也就是进程对应的proc结构体中的锁），但是同时又不能持有任何其他的锁。

首先构建一个不满足这个限制条件的场景：我们有进程P1，P1的内核线程持有了p->lock以外的其他锁，这些锁可能是在使用磁盘，UART，console过程中持有的。之后内核线程在持有锁的时候，通过调用switch/yield/sched函数出让CPU，这会导致进程P1持有了锁，但是进程P1又不在运行。

假设我们在一个只有一个CPU核的机器上，进程P1调用了switch函数将CPU控制转给了调度器线程，调度器线程发现还有一个进程P2的内核线程正在等待被运行，所以调度器线程会切换到运行进程P2。假设P2也想使用磁盘，UART或者console，它会对P1持有的锁调用acquire，这是对于同一个锁的第二个acquire调用。当然这个锁现在已经被P1持有了，所以这里的acquire并不能获取锁。假设这里是spinlock，那么进程P2会在一个循环里不停的“旋转”并等待锁被释放。但是很明显进程P2的acquire不会返回，所以即使进程P2稍后愿意出让CPU，P2也没机会这么做。之所以没机会是因为P2对于锁的acquire调用在直到锁释放之前都不会返回，而唯一锁能被释放的方式就是进程P1恢复执行并在稍后release锁，但是这一步又还没有发生，因为进程P1通过调用switch函数切换到了P2，而P2又在不停的“旋转”并等待锁被释放。这是一种死锁，它会导致系统停止运行。

 

 

本课内容：

sleep和wakeup函数需要通过某种方式链接到一起。也就是说，如果我们调用wakeup函数，我们只想唤醒正在等待刚刚发生的特定事件的线程。所以，sleep函数和wakeup函数都带有一个叫做sleep channel的参数。我们在调用wakeup的时候，需要传入与调用sleep函数相同的sleep channel。不过sleep和wakeup函数只是接收表示了sleep channel的64bit数值，它们并不关心这个数值代表什么。当我们调用sleep函数时，我们通过一个sleep channel表明我们等待的特定事件，当调用wakeup时我们希望能传入相同的数值来表明想唤醒哪个线程。

 

若sleep没有条件锁，转为在sleep前后释放和重新获取条件锁（因为sleep要改变共享区内容或者是为了中断做准备），那么在进入sleep前如果发生了中断（比如说硬件完成了某个操作从而发出一个中断，操作系统响应这个中断并可能执行wakeup），则线程还未有变成sleeping状态，所以中断处理程序中的wakeup并没有唤醒任何进程，因为还没有任何进程在tx_chan上睡眠。之后写线程会继续运行，调用broken_sleep，将进程状态设置为SLEEPING，保存sleep channel。但是中断已经发生了，wakeup也已经被调用了。所以这次的broken_sleep，没有人会唤醒它，因为wakeup已经发生过了。这就是lost wakeup问题。

 

现在我们的目标是消灭掉lost wakeup。这可以通过消除下面的窗口时间来实现。

![img](assets\clip_image002-1729428290858-1.jpg)

首先我们必须要释放uart_tx_lock锁，因为中断需要获取这个锁，但是我们又不能在释放锁和进程将自己标记为SLEEPING之间留有窗口。这样中断处理程序中的wakeup才能看到SLEEPING状态的进程，并将其唤醒，进而我们才可以避免lost wakeup的问题。所以，我们应该消除这里的窗口。

 

为了实现这个目的，我们需要将sleep函数设计的稍微复杂点。这里的解决方法是，即使sleep函数不需要知道你在等待什么事件，它还是需要你知道你在等待什么数据，并且传入一个用来保护你在等待数据的锁。sleep函数需要特定的条件才能执行，而sleep自己又不需要知道这个条件是什么。在我们的例子中，sleep函数执行的特定条件是tx_done等于1。虽然sleep不需要知道tx_done，但是它需要知道保护这个条件的锁，也就是这里的uart_tx_lock。在调用sleep的时候，锁还被当前线程持有，之后这个锁被传递给了sleep。

 

在接口层面，sleep承诺可以原子性的将进程设置成SLEEPING状态，同时释放锁。这样wakeup就不可能看到这样的场景：锁被释放了但是进程还没有进入到SLEEPING状态。所以sleep这里将释放锁和设置进程为SLEEPING状态这两个行为合并为一个原子操作。

 

首先我们来看一下proc.c中的wakeup函数。

![img](assets\clip_image002-1729428308325-3.jpg)wakeup函数并不十分出人意料。它查看整个进程表单，对于每个进程首先加锁，这点很重要。之后查看进程的状态，如果进程当前是SLEEPING并且进程的channel与wakeup传入的channel相同，将进程的状态设置为RUNNABLE。最后再释放进程的锁。

我们已经知道了sleep函数需要释放作为第二个参数传入的锁，这样中断处理程序才能获取锁。函数中第一件事情就是释放这个锁。当然在释放锁之后，我们会担心在这个时间点相应的wakeup会被调用并尝试唤醒当前进程，而当前进程还没有进入到SLEEPING状态。所以我们不能让wakeup在release锁之后执行。为了让它不在release锁之后执行，在release锁之前，sleep会获取即将进入SLEEPING状态的进程的锁。



![img](assets\clip_image004-1729428308325-4.jpg)

wakeup在唤醒一个进程前，需要先获取进程的锁。所以在整个时间uartwrite检查条件之前到sleep函数中调用sched函数之间，这个线程一直持有了保护sleep条件的锁或者p->lock。让我回到UART的代码并强调一下这一点。

![img](assets\clip_image002-1729428372862-7.jpg)

uartwrite在最开始获取了sleep的condition lock，并且一直持有condition lock直到调用sleep函数。所以它首先获取了condition lock，之后检查condition（注，也就是tx_done等于0)，之后在持有condition lock的前提下调用了sleep函数。此时wakeup不能做任何事情，wakeup现在甚至都不能被调用直到调用者能持有condition lock。所以现在wakeup必然还没有执行。

sleep函数在释放condition lock之前，先获取了进程的锁。在释放了condition lock之后，wakeup就可以被调用了，但是除非wakeup获取了进程的锁，否则wakeup不能查看进程的状态。所以，在sleep函数中释放了condition lock之后，wakeup也还没有执行。

在持有进程锁的时候，将进程的状态设置为SLEEPING并记录sleep channel，之后再调用sched函数，这个函数中会再调用switch函数（注，详见11.6），此时sleep函数中仍然持有了进程的锁，wakeup仍然不能做任何事情。

如果你还记得的话，当我们从当前线程切换走时，调度器线程中会释放前一个进程的锁（注，详见11.8）。所以在调度器线程释放进程锁之后，wakeup才能终于获取进程的锁，发现它正在SLEEPING状态，并唤醒它。

**调用sleep**时需要持有condition lock****，这样sleep****函数才能知道相应的锁。

**sleep**函数只有在获取到进程的锁p->lock****之后，才能释放condition lock****。

**wakeup**需要同时持有两个锁才能查看进程。（sleep****最后又重新获取了条件锁）

 

pipe相关见：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec13-sleep-and-wakeup-robert/13.5-sleep-and-wakeup-in-pipe 。

条件锁可以避免别的cpu去改变共享内容。

 

wait不仅是为了父进程方便的知道子进程退出，wait实际上也是进程退出的一个重要组成部分。在Unix中，对于每一个退出的进程，都需要有一个对应的wait系统调用，这就是为什么当一个进程退出时，它的子进程需要变成init进程的子进程。init进程的工作就是在一个循环中不停调用wait，因为每个进程都需要对应一个wait，这样它的父进程才能调用freeproc函数，并清理进程的资源。

直到子进程exit的最后，它都没有释放所有的资源，因为它还在运行的过程中，所以不能释放这些资源。相应的其他的进程，也就是父进程，释放了运行子进程代码所需要的资源。当父进程完成了清理进程的所有资源，子进程的状态会被设置成UNUSED。之后，fork系统调用才能重用进程在进程表单的位置。

 

在kill中它先扫描进程表单，找到目标进程。然后只是将进程的proc结构体中killed标志位设置为1。如果进程正在SLEEPING状态，将其设置为RUNNABLE。这里只是将killed标志位设置为1，并没有停止进程的运行。所以kill系统调用本身还是很温和的。而目标进程运行到内核代码中能安全停止运行的位置时，会检查自己的killed标志位，如果设置为1，目标进程会自愿的执行exit系统调用。

kill系统调用并不是真正的立即停止进程的运行，它更像是这样：如果进程在用户空间，那么下一次它执行系统调用它就会退出，又或者目标进程正在执行用户代码，当时下一次定时器中断或者其他中断触发了，进程才会退出。所以从一个进程调用kill，到另一个进程真正退出，中间可能有很明显的延时。



## lab内容

### Memory allocator:

```c
void kfree(void *pa)

{

 struct run *r;

 if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)

  panic("kfree");

 // Fill with junk to catch dangling refs.

 memset(pa, 1, PGSIZE);

 r = (struct run*)pa;

 acquire(&kmem.lock);

 r->next = kmem.freelist;

 kmem.freelist = r;

 release(&kmem.lock);

}
```

主要作用;将当前页（r,即传进来的物理页）插入到空闲列表的头部。即，将当前页的next指针指向原来的空闲列表头，然后更新空闲列表头为当前页。

 ```c
 Void * kalloc(void)
 
 {
 
  struct run *r;
 
  int cid = cpuid();
 
  acquire(&kmem[cid].lock);
 
  r = kmem[cid].freelist;
 
  if(r)
 
   kmem[cid].freelist = r->next;
 
  release(&kmem[cid].lock);
 
  if(r)
 
   memset((char*)r, 5, PGSIZE); // fill with junk
 
  return (void*)r;
 
 }
 ```

主要作用：r 是一个指向 struct run 类型的指针，这里尝试从对应CPU的空闲列表中取出一个内存页（如果存在的话）。如果空闲列表中有可用页 (r 不为 NULL)，则更新列表头部指针为下一个元素，从而移除当前内存页。

Struct run这个结构体用于表示内存管理中的一个空闲内存块（或内存页）。在这种情况下，它通常用作一个链表节点。

 

要注意的点：如果cpuid超过了最大量（即7，从0开始算），那么要让cpuid置为0。

记得传给函数字符串，用“”括起来，如“xxx”,这是一个常量，不能  函数名（“xxx%d”，i），这是错误的，如果想让里面的字可变，就用

char abc[数组长度要合适，必须超过xxx加上i的长度]；

snprintf（abc，sizeof（abc），“xxx%d”，i）；

函数名（abc）；当然上面这三行都是写在一个for循环里面的。



### Buffer cache

哈希索引一般采取取余的方式。可以不用写函数，直接#define HASH(x) ((x) % NUM_BUCKET)

bcache.heads 是一个指向 struct buf 类型数组(即heads这个数组）的指针，那么 bcache.heads + i 会计算出数组中第 i 个元素的地址（即第几个桶），这个地址就指向第 i 个缓冲区头部。

 

struct buf 结构体是一个缓冲区（buffer）的表示，常用在文件系统的缓存管理中，用于临时存储磁盘块的数据。结构体中各字段的含义如下：

valid: 表示缓冲区是否已从磁盘读取数据，即数据是否有效。

disk: 表示磁盘是否"拥有"这个缓冲区，即缓冲区中的数据是否需要写回到磁盘。

dev: 设备号，标识数据所在的设备。

blockno: 块号，标识数据在设备上的位置。

lock: 用于同步对缓冲区的访问，保证数据的一致性和防止数据竞争。

refcnt: 引用计数，记录有多少进程正在使用这个缓冲区。

prev 和 next: 用于将缓冲区链接到链表中，通常用于实现最近最少使用（LRU）缓存策略。

data: 实际存储的数据，大小为 BSIZE（通常是磁盘块的大小，如512字节或更大）。

 

在文件系统中，设备号（dev）和块号（blockno）是用来唯一确定磁盘上的一个数据块的关键标识。

设备号 (dev)

设备号是用来标识存储设备的一个数字。在一个操作系统中，可能会有多个存储设备（即磁盘，磁盘包括硬盘），比如硬盘、USB驱动器、SSD等。每个设备都会被分配一个唯一的数字来标识，这个数字就是设备号。这样，操作系统可以通过设备号来区分不同的存储设备。

例如，你可能有以下设备：

设备 0: 内部主硬盘

设备 1: 外部USB驱动器

设备 2: 网络存储设备

块号 (blockno)

块号是用来在一个给定的存储设备上标识数据块的编号。存储设备通常被分割成多个固定大小的块，这些块是存储和读取数据的基本单位。块号就是这些数据块的索引。

 

例如，如果一个硬盘被分割成了大小为512字节的块，块号 0 表示硬盘上的第一个512字节，块号 1 表示第二个512字节，以此类推。

示例

假设你的操作系统中有两个存储设备：

内部硬盘（设备号 0）

USB驱动器（设备号 1）

如果你想访问内部硬盘上的第1024个块，你会使用设备号 0 和块号 1023（因为块号通常从 0 开始编号）。

同样，如果你想读取USB驱动器上的第256个数据块，你将使用设备号 1 和块号 255。

这种使用设备号和块号的方式允许文件系统精确地指定和访问存储设备上的任何数据块，无论它位于哪个设备上。这是操作系统进行文件管理和磁盘调度的基础。



#### 步骤1与步骤二：修改结构体及改binit()

本lab想要把缓存块用哈希表和每个哈希桶对应的锁去管理，旧的缓存块如下：

 全局锁

  │

  ▼

 ┌─────────────────────────────┐

 │                         bcache                                         │

 │ ┌─────────────┐ ┌─────────┐      │

 │ │ head                          │ │ buf[NBUF]       │      │

 │ └──────┬──────┘ └──────┬───┘     │

 │                    │                                        │                 │

 └────────┴───────────────┴─────┘

 

链表结构：

 head <-> buf1 <-> buf2 <-> buf3 <-> ... <-> bufN，但设计并实现哈希表以管理缓存块，并为每个哈希桶分配独立的锁#define NUM_BUCKET 13 // 定义哈希桶的数量 

\#define HASH(x) ((x) % NUM_BUCKET)//看是哪一块，哈希散列后就分到对应的桶，图示如下：

struct {

  struct spinlock lock[NUM_BUCKET]; // 每个桶的锁

  struct buf buf[NBUF];       // 缓存池

  struct buf head[NUM_BUCKET];    // 每个桶的链表头

} bcache;

![img](assets\clip_image002-1729428507177-9.jpg)假设您有以下缓存块：

buf1：设备 0，块号 1

buf2：设备 0，块号 2

buf3：设备 1，块号 3

buf4：设备 1，块号 4

buf5：设备 0，块号 5

buf6：设备 2，块号 6

buf7：设备 2，块号 7

buf8：设备 2，块号 8

在旧结构体中，这些缓存块将全部链接在一个链表中，访问任何一个块都需要全局锁来保护。在新结构体中，缓存块将根据哈希函数分配到不同的哈希桶，并使用各自的锁来保护，减少全局锁的争用：

哈希桶分配（示例）：

buf1：桶 0，blockno % NUM_BUCKET = 1 % 13 = 0

buf2：桶 0，blockno % NUM_BUCKET = 2 % 13 = 0

buf3：桶 1，blockno % NUM_BUCKET = 3 % 13 = 1

buf4：桶 1，blockno % NUM_BUCKET = 4 % 13 = 1

buf5：桶 2，blockno % NUM_BUCKET = 5 % 13 = 2

buf6：桶 3，blockno % NUM_BUCKET = 6 % 13 = 3

buf7：桶 3，blockno % NUM_BUCKET = 7 % 13 = 3

buf8：桶 3，blockno % NUM_BUCKET = 8 % 13 = 3

那么最终分布如下：（head 节点通常作为一个固定的参考点，并不存储任何缓存块，要注意它其实是个环状结构head.next 指向链表中的第一个实际缓存块（即最近使用的缓存块）。head.prev 指向链表中的最后一个缓存块（即最少使用的缓存块）。所以buf2和head[0]是互相指着的）

 

├── head[0] <-> buf1 <-> buf2

│

├── head[1] <-> buf3 <-> buf4

│

├── head[2] <-> buf5

│

├── head[3] <-> buf6 <-> buf7 <-> buf8

│

...

**bcache.head + i** **是基于指针算术的结果，它给出的是指向数组第 i** **个元素的指针。**

**在 C** **中，如果你有一个指针 p****，那么 p + i** **是将 p** **的地址向前移动 i** **个元素的位置的指针。**

**因此，bcache.head + i** **实际上是一个指向 bcache.head[i]** **的指针，即 &(bcache.head[i])****。**

**bcache.head[i]** **是访问数组第 i** **个元素的语法，它直接给出了数组第 i** **个元素的值。**

**当你写 bcache.head[i]** **时，实际上是取得 bcache.head** **数组中索引为 i** **的元素。**

**bcache.head[i]****：表示第** **i** **个哈希桶的头结点结构体本身。**

**bcache.head + i****：表示指向第** **i** **个哈希桶的头结点的指针。**

**所以，如果你要直接操作第** **i** **个哈希桶头结点的数据，应该使用** **bcache.head[i]****。如果你需要一个指针指向这个哈希桶头结点，用** **bcache.head + i** **或** **&bcache.head[i]****。**

 

因为prev和next都是指针类型，所以bcache.head[i].prev = bcache.head + i;

​                               bcache.head[i].next = bcache.head + i;

所以也可以写成bcache.head[i].prev = &(bcache.head[i]);这种形式



在修改后的binit函数中：

![img](assets\clip_image002-1729428634171-11.jpg)



#### 步骤三：继续往下看看有什么用到了这个结构体，先改bget

bget()函数不仅🔒受到影响，由于分桶，在本桶没有refcnt == 0的缓存时还需要去其他桶中寻找。基本思路（不实现LRU）：

先寻找是否已经有缓存，若有直接返回

若没有缓存则需要替换refcnt == 0的缓存。可以先在本桶寻找是否有refcnt == 0的缓存，若有则替换后返回。

若本桶没有refcnt == 0的缓存，就需要去其他桶中寻找。若找到，则需要将其从原本桶的list中删去，然后加入本桶的list中。

哈希函数中，X是指缓存块号。

bget()函数不仅🔒受到影响，由于分桶，在本桶没有refcnt == 0的缓存时还需要去其他桶中寻找。基本思路（不实现LRU）：

·     先寻找是否已经有缓存，若有直接返回

·     若没有缓存则需要替换refcnt == 0的缓存。可以先在本桶寻找是否有refcnt == 0的缓存，若有则替换后返回。

·     若本桶没有refcnt == 0的缓存，就需要去其他桶中寻找。若找到，则需要将其从原本桶的list中删去，然后加入本桶的list中。

首先肯定是求出这个缓存块被分配到哪个桶了，用idx=HASH（b->blockno）表示。先获取本桶的锁，之后稍微修改一下// Is the block already cached?部分（即加一些下标等等）。

如果没有缓存，那就在本桶找refcnt为0即最近没用过的缓存块（即在原代码上加工）。

如果本桶没有refcnt为0的缓存块，那么换到另一个桶，不过注意要先释放本桶的锁，换另一个桶，在另一个桶中找refcnt缓存块，所以可以写双层for循环，记得获取当前桶的锁后再进行搜索替换等等的操作避免别的cpu并发修改。

for(jdx = HASH(idx + 1);jdx = HASH(idx + 1); jdx != idx; jdx = (jdx + 1) % NUM_BUCKET)这么写的目的是为了确保即使在跨桶回收操作中，桶的选择仍然符合哈希表的设计目的（即分布比较均匀）。当然直接写成jdx=idx+1…然后遍历每一个桶也可以，不过有些桶可能会被频繁访问，而其它桶则较少访问，从而影响性能。

找到可用缓存块后，替换内容，之后在此桶（即所谓的另一个桶）中的list删去此块（记得释放锁），再将此块加入到本桶中（记得先获取锁，操作完后要释放本桶锁）。

```
删去操作：b->next->prev = b->prev;
```

​     b->prev->next = b->next;

即把b前后两块相连，那么前后两块就不和b连在一起了。

如果到最后都找不到可用块了，记得先release(bcache.locks + jdx);再报panic

 

#### 步骤四：释放缓存块函数及其他

有了上面的经验，这个的操作流程也差不多，先改brelse函数，也是先获取桶号。

（还是记得，bcache.head[idx]是对idx这个桶的head这个结构体做动作，而bcache.head+idx就是指向第几个桶的头结点，bcache.lock+idx指的是那个桶的锁。）

将b从列表删去后（如上面），将b加入到本桶的头结点的左边。这里不会的话就画一下图（记得是双向链表，代码可能得分前后关系否则指代错误）。

之后还有bpin与bunpin，修改完后，本lab就完成了。

 

总结：一般hint里面没说到要在别的文件改的，一般都是要对本文件改，而且一改就是对本文件大改的这种。想不到怎么做，就先全部复制给gpt，让他给出一个步骤出来，之后看看提示再去做，多看几遍总是会的！！！

 

![img](assets\clip_image004-1729428634171-12.jpg)完全公平调度算法（Completely Fair Scheduler，CFS）是Linux内核中的一种进程调度算法，它用于决定哪些进程获得处理器时间，以及它们获得多少时间。CFS首次引入于Linux 2.6.23版本（2007年发布），是由Ingo Molnar设计的。这个调度器是基于公平原则设计的，旨在为运行在系统上的所有进程提供尽可能平等的CPU时间分配。

 

CFS的主要特点和工作原理包括：

基于红黑树的数据结构：CFS使用一种高效的平衡树数据结构（红黑树）来存储处于就绪状态的进程。每个进程都有一个虚拟运行时间，这是一个度量值，用来表示进程已经运行了多久。

 

虚拟运行时间：CFS通过虚拟运行时间来实现公平性。它记录了每个进程的运行时间，并试图确保每个进程都获得相等的处理器时间。虚拟运行时间是调整后的时间，考虑了进程的优先级。

 

最小公平分享（Min vruntime）：调度器选择具有最小虚拟运行时间（vruntime）的进程来运行。这确保了长时间得不到足够CPU时间的进程将获得优先调度。

 

时间片：虽然CFS旨在公平，但它也使用动态时间片，根据系统负载和进程数动态调整。时间片的长度取决于系统中活跃进程的数量，从而保证所有进程获得足够的CPU时间。

 

无固定时间片：与传统的基于固定时间片的调度器不同，CFS分配的时间片长度会根据需要动态变化，以维持系统的公平性和响应性。

 

优先级调整：尽管CFS尽力确保所有进程都能公平地使用CPU，但它仍然支持优先级概念。低优先级（更高的nice值）的进程会获得较少的CPU时间。